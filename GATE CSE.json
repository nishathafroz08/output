[
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting",
    "question": "Which sorting algorithm maintains the relative order of equal elements and is considered stable?",
    "context": "Merge Sort is a stable divide and conquer sorting algorithm that preserves the relative order of equal elements.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Merge Sort",
    "options": [
      "Quick Sort",
      "Merge Sort",
      "Selection Sort",
      "Heap Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Divide and Conquer",
    "question": "Which algorithm uses divide and conquer to sort elements by recursively splitting and merging subarrays?",
    "context": "Merge Sort is a divide and conquer algorithm that recursively splits arrays and merges them in sorted order.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Merge Sort",
    "options": [
      "Bubble Sort",
      "Merge Sort",
      "Insertion Sort",
      "Radix Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Greedy Algorithms",
    "question": "Which problem can be optimally solved using a greedy approach by selecting jobs with the earliest finish time?",
    "context": "The Activity Selection Problem selects the maximum number of activities that don't overlap by using a greedy strategy.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Activity Selection Problem",
    "options": [
      "Activity Selection Problem",
      "Knapsack Problem",
      "Matrix Chain Multiplication",
      "Longest Common Subsequence"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Searching",
    "question": "Which searching technique repeatedly divides the search interval in half for a sorted array?",
    "context": "Binary Search is an efficient algorithm for searching in sorted arrays using a divide and conquer strategy.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Binary Search",
    "options": [
      "Breadth First Search",
      "Binary Search",
      "Depth First Search",
      "Linear Search"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Greedy Algorithms",
    "question": "Which algorithm uses a greedy approach to construct a Minimum Spanning Tree by selecting the least weight edge?",
    "context": "Prim’s Algorithm builds a Minimum Spanning Tree using a greedy strategy by always choosing the smallest weight edge.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Prim's Algorithm",
    "options": [
      "Bellman-Ford Algorithm",
      "Dijkstra's Algorithm",
      "Floyd-Warshall Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Divide and Conquer",
    "question": "Which algorithm finds the k-th smallest element in an unordered list using a divide and conquer approach?",
    "context": "Quickselect is a selection algorithm using a partitioning method similar to quicksort to find the k-th smallest element.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Quickselect",
    "options": [
      "Quicksort",
      "Quickselect",
      "Counting Sort",
      "Heapsort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting",
    "question": "Which algorithm sorts elements by selecting the minimum element and placing it at the beginning of the array?",
    "context": "Selection Sort works by repeatedly selecting the smallest element and placing it at the sorted portion of the array.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Selection Sort",
    "options": [
      "Insertion Sort",
      "Counting Sort",
      "Bubble Sort",
      "Selection Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Sorting & Searching",
    "subtopic": "Binary Search",
    "question": "What is the time complexity of binary search in a sorted array of n elements?",
    "context": "Binary search works by repeatedly dividing the search interval in half, comparing the target with the middle element, and eliminating half of the remaining elements at each step.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(log n)",
    "options": [
      "O(n)",
      "O(log n)",
      "O(1)",
      "O(n log n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Sorting & Searching",
    "subtopic": "Quick Sort",
    "question": "In the worst case scenario, what is the time complexity of Quick Sort?",
    "context": "Quick Sort's worst case occurs when the pivot is always the smallest or largest element, leading to unbalanced partitions where one partition has n-1 elements and the other has 0 elements.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O(n²)",
    "options": [
      "O(n²)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Divide and Conquer",
    "subtopic": "Merge Sort",
    "question": "Which property makes Merge Sort particularly suitable for sorting linked lists?",
    "context": "Merge Sort maintains stability by preserving the relative order of equal elements and can sort linked lists without requiring additional space for merging, unlike arrays where O(n) extra space is needed.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Stable sorting with O(1) space complexity for linked lists",
    "options": [
      "Stable sorting with O(1) space complexity for linked lists",
      "Better cache performance than other algorithms",
      "Adaptive nature for partially sorted data",
      "In-place sorting capability"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Divide and Conquer",
    "subtopic": "Master Theorem",
    "question": "For the recurrence relation T(n) = 2T(n/2) + O(n), what is the time complexity according to Master Theorem?",
    "context": "Using Master Theorem case 2, where a=2, b=2, and f(n)=O(n). Since f(n) = Θ(n^(log_b(a))) = Θ(n¹), the solution is Θ(n^(log_b(a)) × log n) = Θ(n log n).",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "O(n log n)",
    "options": [
      "O(n log n)",
      "O(log n)",
      "O(n²)",
      "O(n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Greedy Algorithms",
    "subtopic": "Activity Selection",
    "question": "In the Activity Selection Problem, which greedy choice leads to the optimal solution?",
    "context": "The greedy approach for Activity Selection Problem works by always choosing the activity that finishes earliest among the remaining activities, as this leaves maximum room for selecting subsequent activities.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Select activity with earliest finish time",
    "options": [
      "Select activity with shortest duration",
      "Select activity with earliest start time",
      "Select activity with maximum profit per unit time",
      "Select activity with earliest finish time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Greedy Algorithms",
    "subtopic": "Huffman Coding",
    "question": "What data structure is primarily used in Huffman Coding algorithm implementation?",
    "context": "Huffman Coding uses a min heap to repeatedly extract the two nodes with minimum frequency and merge them to build the optimal prefix-free binary tree for encoding.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Min Heap (Priority Queue)",
    "options": [
      "Max Heap",
      "Min Heap (Priority Queue)",
      "Stack",
      "Hash Table"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Sorting & Searching",
    "subtopic": "Heap Sort",
    "question": "What is the space complexity of Heap Sort algorithm?",
    "context": "Heap Sort is an in-place sorting algorithm that transforms the input array into a heap structure and then repeatedly extracts the maximum element, requiring only constant extra space for variables.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(1)",
    "options": [
      "O(1)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting",
    "question": "Which sorting algorithm has the best average-case time complexity for sorting a random array of integers?",
    "context": "Quick Sort has an average-case time complexity of O(n log n) due to its divide-and-conquer strategy, making it efficient for large datasets compared to simpler sorting algorithms.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Quick Sort",
    "options": [
      "Quick Sort",
      "Bubble Sort",
      "Selection Sort",
      "Insertion Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Searching",
    "question": "What is the time complexity of Binary Search when applied to a sorted array of n elements?",
    "context": "Binary Search divides the search interval in half repeatedly, resulting in a logarithmic time complexity of O(log n) for a sorted array.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(log n)",
    "options": [
      "O(1)",
      "O(n log n)",
      "O(n)",
      "O(log n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Divide and Conquer",
    "question": "Which algorithm uses the Divide and Conquer strategy to find the closest pair of points in a set of n points in a 2D plane?",
    "context": "The Closest Pair Algorithm uses a Divide and Conquer approach to split points into subsets, achieving a time complexity of O(n log n) for finding the closest pair in a 2D plane.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Closest Pair Algorithm",
    "options": [
      "Kruskal's Algorithm",
      "Dijkstra's Algorithm",
      "Closest Pair Algorithm",
      "Prim's Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Greedy Algorithms",
    "question": "Which greedy algorithm is used to find the minimum spanning tree of a connected, undirected graph?",
    "context": "Kruskal's Algorithm is a greedy algorithm that selects edges in increasing order of weight to form a minimum spanning tree, ensuring no cycles are formed.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Kruskal's Algorithm",
    "options": [
      "Floyd-Warshall Algorithm",
      "Bellman-Ford Algorithm",
      "A* Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting",
    "question": "Which sorting algorithm is most efficient for sorting a nearly sorted array where each element is at most k positions away from its sorted position?",
    "context": "Insertion Sort performs efficiently on nearly sorted arrays with a time complexity of O(nk) in such cases, as it only needs to make small adjustments to place elements correctly.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Insertion Sort",
    "options": [
      "Insertion Sort",
      "Merge Sort",
      "Quick Sort",
      "Heap Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Searching",
    "question": "Which search algorithm is optimal for searching in a rotated sorted array with no duplicates?",
    "context": "Modified Binary Search adapts the standard Binary Search to handle rotated sorted arrays by determining which half is sorted and continuing the search in the appropriate half, maintaining O(log n) complexity.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Modified Binary Search",
    "options": [
      "Exponential Search",
      "Modified Binary Search",
      "Jump Search",
      "Linear Search"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Greedy Algorithms",
    "question": "Which greedy algorithm is used to solve the activity selection problem when activities have start and finish times?",
    "context": "The Activity Selection Algorithm greedily selects the maximum number of non-overlapping activities by choosing the activity with the earliest finish time at each step.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Activity Selection Algorithm",
    "options": [
      "Activity Selection Algorithm",
      "Huffman Coding",
      "Job Sequencing",
      "Fractional Knapsack"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting & Searching",
    "question": "A software development team needs to frequently query a large, dynamic dataset for specific customer records. Which data structure and search algorithm combination would provide the most efficient average-case performance for retrieval, assuming no prior knowledge of data distribution?",
    "context": "Hash tables offer average-case O(1) time complexity for search, insertion, and deletion operations, making them highly efficient for frequent data retrieval in dynamic datasets. Binary search is efficient on sorted data, but sorting can be costly for dynamic sets.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Hash Table with Average O(1) Search",
    "options": [
      "Binary Search Tree (BST) with Average O(log n) Search",
      "Hash Table with Average O(1) Search",
      "Linked List with Linear Search (O(n))",
      "Sorted Array with Binary Search (O(log n))"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Divide and Conquer",
    "question": "A new feature in an e-commerce application requires finding the two closest product prices from a list of millions of prices to suggest alternative options. Which algorithmic paradigm is most suitable for efficiently solving this problem, and why?",
    "context": "The closest pair of points problem, which is analogous to finding closest prices, is typically solved efficiently using the Divide and Conquer paradigm. This approach recursively divides the set of points into two halves, finds the closest pair in each half, and then finds the closest pair across the dividing line.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Divide and Conquer, due to its ability to break down the problem into smaller, independent subproblems and combine their solutions.",
    "options": [
      "Divide and Conquer, due to its ability to break down the problem into smaller, independent subproblems and combine their solutions.",
      "Greedy Algorithms, as they focus on making locally optimal choices without global consideration.",
      "Dynamic Programming, as it is primarily used for problems with overlapping subproblems and optimal substructure.",
      "Brute Force, due to its simplicity but O(n^2) time complexity for this problem."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Greedy Algorithms",
    "question": "A software project manager needs to schedule a set of tasks with varying durations and deadlines on a single processor to maximize the number of completed tasks. Which type of algorithm is generally best suited for this problem, and what is its core principle?",
    "context": "The activity selection problem, a classic example of a problem solvable with a greedy approach, aims to select the maximum number of non-overlapping activities. A common greedy strategy is to always pick the activity that finishes earliest.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Greedy Algorithm, by prioritizing tasks with the earliest deadlines.",
    "options": [
      "Backtracking, by systematically trying all possible task orderings.",
      "Dynamic Programming, by storing and reusing solutions to subproblems to avoid redundant computations.",
      "Divide and Conquer, by breaking down tasks into smaller, manageable sub-tasks.",
      "Greedy Algorithm, by prioritizing tasks with the earliest deadlines."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting & Searching",
    "question": "In a cloud-based document management system, users frequently upload new versions of documents. Which sorting algorithm would be most efficient for maintaining a sorted list of document versions by upload time, considering that the list is mostly sorted already?",
    "context": "Insertion Sort performs well on nearly sorted arrays. Its time complexity approaches O(n) in such scenarios, making it more efficient than other comparison-based sorting algorithms like Merge Sort, Quick Sort, or Heap Sort which have an average time complexity of O(n log n) regardless of the input's sortedness.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Insertion Sort",
    "options": [
      "Merge Sort",
      "Quick Sort",
      "Insertion Sort",
      "Heap Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Divide and Conquer",
    "question": "A distributed system needs to find the maximum element across millions of nodes efficiently. How can the Divide and Conquer paradigm be applied to solve this problem in a highly parallelizable manner?",
    "context": "Divide and Conquer is well-suited for parallel computation. To find the maximum element, the set of nodes can be divided into smaller groups, and the maximum can be found independently in each group. These results are then combined to find the overall maximum, allowing for parallel execution on different processors.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Recursively find the maximum in subsets of nodes, then combine results.",
    "options": [
      "Employ dynamic programming to build up the maximum value from smaller segments.",
      "Iteratively compare elements from each node in a centralized fashion.",
      "Use a greedy approach by always picking the largest element seen so far.",
      "Recursively find the maximum in subsets of nodes, then combine results."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Greedy Algorithms",
    "question": "For a software engineer developing an algorithm to find the minimum number of coins to make a given change amount, which greedy strategy works for standard coin denominations (e.g., 1, 5, 10, 25 cents), and why might it fail for arbitrary denominations?",
    "context": "The greedy coin change algorithm works for canonical coin systems (like USD or EUR) because of their specific denominations. However, it fails for non-canonical systems (e.g., if denominations were 1, 3, 4 cents and the target was 6, greedy would pick 4+1+1, while optimal is 3+3). This highlights that greedy choices don't always lead to global optimality.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Always pick the largest denomination less than or equal to the remaining amount. It fails for arbitrary denominations because the globally optimal choice might not be achieved by locally optimal steps.",
    "options": [
      "Use dynamic programming as it is the only way to guarantee an optimal solution for all denominations.",
      "Always pick the largest denomination less than or equal to the remaining amount. It fails for arbitrary denominations because the globally optimal choice might not be achieved by locally optimal steps.",
      "Randomly pick denominations until the amount is met. It is computationally inefficient.",
      "Always pick the smallest denomination first. It always works for any denominations."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Sorting & Searching",
    "question": "A software engineer is tasked with implementing a highly optimized search function for a real-time system where data changes very frequently. Given the need for minimal search latency, and accepting a potential trade-off in memory usage, which searching technique should be considered?",
    "context": "Hashing provides average-case O(1) search time, which is crucial for real-time systems requiring minimal latency. While it can consume more memory due to potential empty slots or collision resolution overhead, its speed often outweighs this for performance-critical applications. Binary search requires a sorted array, which is difficult to maintain with frequent changes, and linear search is too slow for large datasets.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Hashing with a well-designed hash function and collision resolution.",
    "options": [
      "Hashing with a well-designed hash function and collision resolution.",
      "Linear Search on an unsorted linked list.",
      "Breadth-First Search on a graph representation.",
      "Binary Search on a sorted array."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Dynamic Programming",
    "question": "Which technique solves problems by breaking them into overlapping subproblems and storing their results to avoid recomputation?",
    "context": "Dynamic Programming solves complex problems by breaking them into smaller overlapping subproblems and caching their results.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Dynamic Programming",
    "options": [
      "Greedy Algorithm",
      "Backtracking",
      "Dynamic Programming",
      "Divide and Conquer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms",
    "question": "Which algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative edges?",
    "context": "Dijkstra’s Algorithm computes the shortest path from a source node to all other nodes in a graph with non-negative edge weights.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Dijkstra's Algorithm",
    "options": [
      "Dijkstra's Algorithm",
      "Kruskal's Algorithm",
      "Prim's Algorithm",
      "Floyd-Warshall Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms",
    "question": "Which traversal algorithm uses a queue to explore all nodes at the present depth before moving to the next level?",
    "context": "Breadth First Search (BFS) uses a queue to visit all nodes level by level and is commonly used in unweighted shortest path finding.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Breadth First Search",
    "options": [
      "Breadth First Search",
      "Topological Sort",
      "Dijkstra’s Algorithm",
      "Depth First Search"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "NP-Completeness",
    "question": "Which class of problems is characterized by the property that solutions can be verified in polynomial time?",
    "context": "NP is a complexity class where a given solution can be verified in polynomial time, even if finding the solution is hard.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "NP",
    "options": [
      "NP",
      "P",
      "EXP",
      "NP-Hard"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "NP-Completeness",
    "question": "Which problem is a classic example of an NP-Complete problem often used to reduce other problems?",
    "context": "The Boolean Satisfiability Problem (SAT) is the first proven NP-Complete problem and is widely used in reductions.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Boolean Satisfiability Problem (SAT)",
    "options": [
      "Greatest Common Divisor",
      "Primality Testing",
      "Boolean Satisfiability Problem (SAT)",
      "Sorting"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms",
    "question": "Which algorithm constructs a Minimum Spanning Tree by always selecting the edge with the smallest weight that doesn’t form a cycle?",
    "context": "Kruskal’s Algorithm is a greedy method that builds a Minimum Spanning Tree by choosing the lowest weight edges without forming cycles.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Kruskal’s Algorithm",
    "options": [
      "Prim’s Algorithm",
      "Dijkstra’s Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Dynamic Programming",
    "question": "Which problem is typically solved using dynamic programming by storing optimal substructure values in a 2D table?",
    "context": "The Longest Common Subsequence (LCS) problem uses a 2D dynamic programming table to store lengths of matching subsequences.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Longest Common Subsequence",
    "options": [
      "Merge Sort",
      "Breadth First Search",
      "Quickselect",
      "Longest Common Subsequence"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Dynamic Programming",
    "subtopic": "Longest Common Subsequence",
    "question": "What is the time complexity of finding the Longest Common Subsequence (LCS) of two strings of length m and n using dynamic programming?",
    "context": "The LCS problem uses a 2D DP table where each cell [i][j] represents the length of LCS of first i characters of string1 and first j characters of string2, requiring O(m × n) time to fill the entire table.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(m × n)",
    "options": [
      "O(m × n)",
      "O(2^(m+n))",
      "O(m × n × log(min(m,n)))",
      "O(m + n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Dynamic Programming",
    "subtopic": "0/1 Knapsack",
    "question": "In the 0/1 Knapsack problem with n items and capacity W, what is the space complexity of the optimized DP solution?",
    "context": "The 0/1 Knapsack problem can be solved using space optimization where only the current and previous rows of the DP table are maintained, reducing space complexity from O(n × W) to O(W) by using a 1D array.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O(W)",
    "options": [
      "O(n × W)",
      "O(n + W)",
      "O(n)",
      "O(W)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Algorithms",
    "subtopic": "Breadth-First Search",
    "question": "What data structure is essential for implementing Breadth-First Search (BFS) traversal?",
    "context": "BFS explores vertices level by level, visiting all vertices at distance k before visiting vertices at distance k+1. A queue (FIFO structure) ensures this order by adding neighbors to the rear and processing vertices from the front.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Queue",
    "options": [
      "Priority Queue",
      "Hash Table",
      "Queue",
      "Stack"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Algorithms",
    "subtopic": "Dijkstra's Algorithm",
    "question": "What is the time complexity of Dijkstra's algorithm when implemented using a binary heap?",
    "context": "Dijkstra's algorithm using binary heap performs V extract-min operations (each taking O(log V)) and up to E decrease-key operations (each taking O(log V)), resulting in O((V + E) log V) total complexity.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O((V + E) log V)",
    "options": [
      "O(V²)",
      "O(V log V + E)",
      "O((V + E) log V)",
      "O(E log E)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Algorithms",
    "subtopic": "Minimum Spanning Tree",
    "question": "Which property must be satisfied by any Minimum Spanning Tree (MST) of a connected graph with n vertices?",
    "context": "A Minimum Spanning Tree of a connected graph with n vertices is a tree that spans all vertices with minimum total edge weight. Since it's a tree, it must contain exactly (n-1) edges and be acyclic.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Contains exactly (n-1) edges",
    "options": [
      "Contains at least one cycle",
      "Contains exactly (n-1) edges",
      "All edges have the same weight",
      "Contains exactly n edges"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "NP-Completeness and Approximation",
    "subtopic": "P vs NP",
    "question": "Which statement correctly describes the relationship between P and NP complexity classes?",
    "context": "The class P contains problems solvable in polynomial time, while NP contains problems verifiable in polynomial time. Since any problem solvable in polynomial time is also verifiable in polynomial time, P ⊆ NP. However, whether P = NP remains the most famous unsolved problem in computer science.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "P ⊆ NP, but whether P = NP is unknown",
    "options": [
      "P = NP has been proven true",
      "P ⊆ NP, but whether P = NP is unknown",
      "P and NP are disjoint sets",
      "NP ⊆ P has been proven true"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "NP-Completeness and Approximation",
    "subtopic": "TSP Approximation",
    "question": "What is the approximation ratio of the Christofides algorithm for the Traveling Salesman Problem (TSP)?",
    "context": "The Christofides algorithm provides a 3/2-approximation for the metric TSP by finding an MST, identifying odd-degree vertices, finding minimum-weight perfect matching on them, and combining to create an Eulerian graph before converting to Hamiltonian cycle.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "3/2",
    "options": [
      "1.5 log n",
      "3/2",
      "2",
      "√n"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Dynamic Programming",
    "question": "Which problem can be solved using Dynamic Programming to find the length of the longest common subsequence of two strings?",
    "context": "The Longest Common Subsequence (LCS) problem uses Dynamic Programming to build a table that stores lengths of common subsequences, achieving a time complexity of O(mn) for strings of lengths m and n.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Longest Common Subsequence",
    "options": [
      "Knapsack Problem",
      "Longest Common Subsequence",
      "Longest Increasing Subsequence",
      "Matrix Chain Multiplication"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms",
    "question": "Which graph traversal algorithm explores all neighbors of a vertex before moving to the next level of vertices?",
    "context": "Breadth-First Search (BFS) uses a queue to explore vertices level by level, ensuring all neighbors at the current depth are visited before moving deeper.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Breadth-First Search",
    "options": [
      "Dijkstra’s Algorithm",
      "Breadth-First Search",
      "Prim’s Algorithm",
      "Depth-First Search"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms",
    "question": "Which algorithm finds the shortest path from a single source to all other vertices in a weighted graph with non-negative edge weights?",
    "context": "Dijkstra’s Algorithm uses a priority queue to greedily select the vertex with the smallest tentative distance, achieving a time complexity of O((V + E) log V) with a binary heap.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Dijkstra’s Algorithm",
    "options": [
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm",
      "Floyd-Warshall Algorithm",
      "Dijkstra’s Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Dynamic Programming",
    "question": "Which Dynamic Programming problem involves selecting items with given weights and values to maximize value within a knapsack’s capacity?",
    "context": "The 0/1 Knapsack Problem uses a Dynamic Programming table to decide whether to include each item, with a time complexity of O(nW) where n is the number of items and W is the capacity.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "0/1 Knapsack Problem",
    "options": [
      "0/1 Knapsack Problem",
      "Longest Palindromic Subsequence",
      "Edit Distance",
      "Fractional Knapsack Problem"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms",
    "question": "Which algorithm constructs a minimum spanning tree by repeatedly adding the smallest edge that connects a vertex in the tree to a vertex outside it?",
    "context": "Prim’s Algorithm grows a minimum spanning tree by selecting the smallest edge connecting the tree to an unvisited vertex, with a time complexity of O((V + E) log V) using a priority queue.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Prim’s Algorithm",
    "options": [
      "A* Algorithm",
      "Bellman-Ford Algorithm",
      "Kruskal’s Algorithm",
      "Prim’s Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "NP-Completeness",
    "question": "Which of the following problems is known to be NP-Complete and involves finding a subset of vertices that covers all edges in a graph?",
    "context": "The Vertex Cover Problem is NP-Complete, requiring the smallest set of vertices such that each edge in the graph is incident to at least one vertex in the set.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Vertex Cover Problem",
    "options": [
      "Minimum Spanning Tree",
      "Vertex Cover Problem",
      "Topological Sort",
      "Shortest Path Problem"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Approximation Algorithms",
    "question": "Which approximation algorithm provides a 2-approximation for the Vertex Cover Problem in polynomial time?",
    "context": "The Greedy Vertex Cover algorithm selects edges and includes both endpoints in the cover, ensuring a solution no more than twice the size of the optimal vertex cover in polynomial time.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Greedy Vertex Cover",
    "options": [
      "Greedy Vertex Cover",
      "Randomized Rounding",
      "Greedy Knapsack",
      "Greedy Set Cover"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Dynamic Programming",
    "question": "A software company is building a recommendation engine that needs to find the longest common subsequence between two user's movie watch histories to suggest similar films. Which algorithmic paradigm is best suited for this task, and why?",
    "context": "The Longest Common Subsequence (LCS) problem is a classic application of dynamic programming. It exhibits optimal substructure (an optimal solution to the LCS problem contains optimal solutions to subproblems) and overlapping subproblems (the same subproblems are solved multiple times if not memoized or tabulated).",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Dynamic Programming, because it efficiently solves problems with overlapping subproblems and optimal substructure by storing intermediate results.",
    "options": [
      "Divide and Conquer, as breaking the problem into independent subproblems does not directly leverage the overlapping nature of common subsequences.",
      "Greedy Algorithms, as they make locally optimal choices which may not lead to a globally optimal longest common subsequence.",
      "Backtracking, as it would explore too many redundant paths, leading to inefficiency for larger watch histories.",
      "Dynamic Programming, because it efficiently solves problems with overlapping subproblems and optimal substructure by storing intermediate results."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms (BFS, DFS, Dijkstra, MST)",
    "question": "A network administrator needs to determine the shortest path for data packets from a central server to all other servers in a large, weighted network, where link costs represent latency. Which graph algorithm should be employed?",
    "context": "Dijkstra's Algorithm finds the shortest paths from a single source node to all other nodes in a graph with non-negative edge weights. BFS finds shortest paths in unweighted graphs, while DFS is for traversal. Prim's Algorithm finds a Minimum Spanning Tree, not shortest paths.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Dijkstra's Algorithm",
    "options": [
      "Prim's Algorithm for Minimum Spanning Tree",
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "NP-Completeness and Approximation",
    "question": "A logistics company is trying to optimize delivery routes for a large fleet of vehicles to minimize total travel distance, visiting each customer exactly once. This problem is known to be computationally hard. What complexity class does it belong to, and why is an exact solution often impractical for large instances?",
    "context": "The Traveling Salesperson Problem (TSP), which describes visiting each customer exactly once to minimize total distance, is a classic example of an NP-hard problem. This means no known polynomial-time algorithm exists for finding the optimal solution, making exact solutions impractical for large instances and necessitating the use of approximation algorithms or heuristics.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "NP-hard, because there is no known polynomial-time algorithm to find an optimal solution, and verifying a solution is easy.",
    "options": [
      "Undecidable, because no algorithm can solve it in finite time.",
      "NP-hard, because there is no known polynomial-time algorithm to find an optimal solution, and verifying a solution is easy.",
      "NP-complete, because it is both in NP and NP-hard, and a solution can be found in polynomial time.",
      "P-class, because a polynomial-time algorithm exists for all instances."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Dynamic Programming",
    "question": "Consider a scenario where a financial institution needs to calculate the maximum profit that can be obtained by buying and selling a stock exactly once, given a sequence of stock prices over 'n' days. How can dynamic programming be applied to efficiently solve this?",
    "context": "The 'Best Time to Buy and Sell Stock' problem (with one transaction) can be solved using a dynamic programming approach in O(n) time. The key is to maintain a variable for the minimum price encountered so far and, for each subsequent price, calculate the potential profit and update the maximum profit found.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "By iterating through the prices, keeping track of the minimum price seen so far and updating the maximum profit.",
    "options": [
      "By using a greedy approach, always buying at the lowest point and selling at the next highest, which might miss the global optimum.",
      "By iterating through the prices, keeping track of the minimum price seen so far and updating the maximum profit.",
      "By dividing the problem into smaller time intervals and solving them independently, without considering dependencies.",
      "By exhaustively checking every possible buy and sell pair, leading to O(n^2) complexity."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms (BFS, DFS, Dijkstra, MST)",
    "question": "A social media platform wants to identify all users reachable within 'k' degrees of separation from a given user to suggest new connections. Which graph traversal algorithm is most suitable for this task?",
    "context": "BFS is ideal for finding the shortest path in unweighted graphs and for exploring all nodes at a given 'depth' or distance from a starting node. This directly applies to finding users within a specific number of connections (degrees of separation). DFS explores branches as far as possible before backtracking.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Breadth-First Search (BFS)",
    "options": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Prim's Algorithm",
      "Dijkstra's Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "NP-Completeness and Approximation",
    "question": "In the context of designing scheduling algorithms for a multi-core processor, a critical challenge is to find an optimal assignment of tasks to cores to minimize the total execution time, given that tasks have dependencies. If this problem is proven to be NP-complete, what implication does this have for a software developer?",
    "context": "If a problem is NP-complete, it implies that it's as hard as any problem in NP, and no polynomial-time algorithm is known to exist for it. Therefore, for large instances, developers typically resort to approximation algorithms that provide a 'good enough' solution within a reasonable time, rather than an absolute optimal solution.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "An exact polynomial-time algorithm is unlikely to exist, so heuristic or approximation algorithms are often the practical solution.",
    "options": [
      "Only brute-force solutions are possible, regardless of problem size.",
      "The problem can be solved in polynomial time with a clever algorithm.",
      "The problem is undecidable, meaning no algorithm can ever solve it.",
      "An exact polynomial-time algorithm is unlikely to exist, so heuristic or approximation algorithms are often the practical solution."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Algorithms",
    "subtopic": "Graph Algorithms (BFS, DFS, Dijkstra, MST)",
    "question": "During the development of a compiler, a crucial step involves detecting cycles in a program's call graph to identify potential infinite recursion. Which graph traversal algorithm is most suitable for efficiently identifying the presence of cycles?",
    "context": "Depth-First Search (DFS) is particularly effective for cycle detection in graphs. During a DFS traversal, if an already visited node (that is still in the current recursion stack) is encountered, it indicates the presence of a cycle. BFS is generally used for shortest paths in unweighted graphs, while Kruskal's and Floyd-Warshall are for MST and all-pairs shortest paths respectively.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Depth-First Search (DFS)",
    "options": [
      "Breadth-First Search (BFS)",
      "Depth-First Search (DFS)",
      "Floyd-Warshall Algorithm",
      "Kruskal's Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Arrays, Linked Lists, Stacks, Queues",
    "question": "A software engineer is developing a feature for a music streaming application that allows users to 'undo' their last listened song. Which data structure is most appropriate to efficiently implement this 'undo' functionality?",
    "context": "A Stack operates on a Last-In, First-Out (LIFO) principle, where the last item added is the first one to be removed. This behavior perfectly aligns with an 'undo' functionality, where the most recent action is the one to be reversed.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Stack",
    "options": [
      "Queue",
      "Linked List",
      "Array",
      "Stack"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Arrays, Linked Lists, Stacks, Queues",
    "question": "In a highly concurrent system managing incoming sensor data, where data must be processed in the order it arrives, which data structure offers the most efficient way to handle this 'first-in, first-out' processing?",
    "context": "A Queue follows a First-In, First-Out (FIFO) principle, meaning elements are processed in the order they are added. This is ideal for scenarios like processing incoming data streams or managing tasks where the order of arrival dictates the order of service.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Queue",
    "options": [
      "Queue",
      "Array",
      "Doubly Linked List",
      "Stack"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Trees (Binary, BST, AVL, B-Trees)",
    "question": "A database system frequently performs range queries (e.g., retrieve all records where a key is between X and Y). Which type of balanced binary search tree is particularly well-suited for efficient range query operations due to its structure and properties?",
    "context": "B-Trees are multi-way trees commonly used in database and file systems because they are optimized for disk-based storage. Their high branching factor (many children per node) and ordered structure allow for efficient range queries and sequential access by minimizing disk I/O operations.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "B-Tree",
    "options": [
      "Binary Search Tree (unbalanced)",
      "B-Tree",
      "Red-Black Tree",
      "AVL Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Trees (Binary, BST, AVL, B-Trees)",
    "question": "A software engineer is designing an in-memory dictionary for a programming language interpreter, where frequent insertions, deletions, and lookups of keywords are expected. Which self-balancing binary search tree guarantees O(log n) time complexity for these operations in all cases?",
    "context": "AVL trees are self-balancing binary search trees that maintain a balance factor for each node, ensuring that the height difference between the left and right subtrees is at most 1. This strict balancing guarantees O(log n) time complexity for search, insertion, and deletion operations in the worst case, making them highly reliable for performance-critical applications.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "AVL Tree",
    "options": [
      "Trie",
      "AVL Tree",
      "B-Tree",
      "Binary Search Tree (unbalanced)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Heaps",
    "question": "In a real-time operating system, tasks are prioritized based on their urgency, and the highest-priority task must always be executed next. Which data structure is ideal for efficiently managing and extracting the highest-priority task?",
    "context": "A Max Heap is a complete binary tree where the value of each node is greater than or equal to the value of its children. This property ensures that the maximum element is always at the root, allowing for O(1) access to the highest-priority task and O(log n) for extraction and insertion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Max Heap",
    "options": [
      "Queue",
      "Max Heap",
      "Binary Search Tree",
      "Min Heap"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Heaps",
    "question": "A network monitoring tool collects latency data from various servers. The tool needs to quickly identify the server with the lowest latency at any given moment. Which heap variant would be most suitable for this purpose?",
    "context": "A Min Heap is a complete binary tree where the value of each node is less than or equal to the value of its children. This structure ensures that the minimum element is always at the root, making it highly efficient for quickly retrieving the smallest value, such as the lowest latency.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Min Heap",
    "options": [
      "Binary Search Tree",
      "Fibonacci Heap",
      "Min Heap",
      "Max Heap"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Arrays, Linked Lists, Stacks, Queues",
    "question": "A software team is developing a text editor that requires efficient insertion and deletion of characters anywhere within a large document. Which data structure would be the most suitable choice to handle these dynamic operations without significant performance overhead for shifts?",
    "context": "A Doubly Linked List allows for efficient insertion and deletion of nodes (characters) at any position in O(1) time (once the position is found) because it maintains pointers to both the previous and next nodes. In contrast, arrays require O(n) time for insertions/deletions as elements need to be shifted, and singly linked lists only allow efficient insertion/deletion after traversing to the preceding node.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Doubly Linked List",
    "options": [
      "Circular Queue",
      "Singly Linked List",
      "Array",
      "Doubly Linked List"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Arrays",
    "question": "Which operation in an array has a time complexity of O(n) in the worst case when accessing elements by index?",
    "context": "Shifting elements in an array, such as during insertion or deletion in the middle, requires moving subsequent elements, resulting in O(n) time complexity in the worst case.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Shifting elements",
    "options": [
      "Appending at the end",
      "Shifting elements",
      "Searching in a sorted array",
      "Accessing by index"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Linked Lists",
    "question": "Which type of linked list allows traversal in both directions and efficient insertion/deletion at both ends?",
    "context": "A Doubly Linked List has nodes with pointers to both the next and previous nodes, enabling bidirectional traversal and O(1) insertion/deletion at the head or tail.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Doubly Linked List",
    "options": [
      "Singly Linked List",
      "Circular Linked List",
      "Skip List",
      "Doubly Linked List"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Stacks",
    "question": "Which data structure is best suited for implementing a function call stack in a recursive program?",
    "context": "A Stack follows the Last-In-First-Out (LIFO) principle, making it ideal for managing function calls in recursion, as the most recent call is popped first.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Stack",
    "options": [
      "Stack",
      "Binary Tree",
      "Heap",
      "Queue"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Queues",
    "question": "Which queue variant allows insertion at both ends but deletion only at the front?",
    "context": "A Deque (Double-Ended Queue) supports insertion at both ends and deletion at the front, providing flexibility over a simple queue while maintaining O(1) operations for these tasks.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Deque",
    "options": [
      "Circular Queue",
      "Deque",
      "Simple Queue",
      "Priority Queue"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Trees",
    "question": "Which self-balancing binary search tree ensures that the height difference between left and right subtrees of any node is at most 1?",
    "context": "An AVL Tree maintains balance by ensuring the balance factor of each node is -1, 0, or 1, guaranteeing O(log n) time for search, insertion, and deletion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "AVL Tree",
    "options": [
      "B-Tree",
      "AVL Tree",
      "Red-Black Tree",
      "Binary Search Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Trees",
    "question": "Which tree data structure is commonly used in databases and file systems to minimize disk I/O operations?",
    "context": "B-Trees are multi-way balanced trees designed to reduce disk I/O by keeping multiple keys in each node and maintaining a low height, making them ideal for databases and file systems.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "B-Tree",
    "options": [
      "B-Tree",
      "Heap",
      "AVL Tree",
      "Binary Search Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Heaps",
    "question": "Which heap operation can be used to efficiently find the kth smallest element in an unsorted array?",
    "context": "Building a Min-Heap from an array takes O(n) time, and extracting the minimum k times yields the kth smallest element in O(n + k log n) time, efficient for small k.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Build Min-Heap",
    "options": [
      "Build Min-Heap",
      "Priority Queue Dequeue",
      "Build Max-Heap",
      "Heap Sort"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Arrays",
    "question": "What is the time complexity of accessing an element at a given index in an array?",
    "context": "Arrays provide random access to elements using index-based addressing. Since the memory address of any element can be calculated directly using the base address and index (address = base + index × size), access time is constant regardless of array size.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(1)",
    "options": [
      "O(n)",
      "O(log n)",
      "O(n log n)",
      "O(1)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Linked Lists",
    "question": "What is the main advantage of a doubly linked list over a singly linked list?",
    "context": "Doubly linked lists maintain both next and previous pointers, allowing bidirectional traversal and O(1) deletion of a node when given its reference, unlike singly linked lists which require O(n) time to find the previous node for deletion.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Efficient backward traversal and deletion of given node",
    "options": [
      "Efficient backward traversal and deletion of given node",
      "Faster insertion at the beginning",
      "Lower memory usage per node",
      "Better cache locality"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Stacks and Queues",
    "question": "Which data structure is most suitable for implementing function call management in programming languages?",
    "context": "Function calls follow Last-In-First-Out (LIFO) order where the most recently called function must complete first before returning to the previous function. Stack's LIFO property makes it ideal for managing function call frames, local variables, and return addresses.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Stack",
    "options": [
      "Circular Queue",
      "Queue",
      "Priority Queue",
      "Stack"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Trees",
    "subtopic": "Binary Search Tree",
    "question": "In a balanced Binary Search Tree with n nodes, what is the time complexity of search, insertion, and deletion operations?",
    "context": "In a balanced BST, the height is approximately log₂(n). Since search, insertion, and deletion operations traverse from root to leaf in the worst case, they all have O(log n) time complexity due to the logarithmic height of the balanced tree.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(log n)",
    "options": [
      "O(n log n)",
      "O(n)",
      "O(log n)",
      "O(1)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Trees",
    "subtopic": "AVL Tree",
    "question": "What is the maximum difference in heights between left and right subtrees allowed in an AVL tree?",
    "context": "AVL trees maintain the balance factor property where for every node, the height difference between left and right subtrees must be at most 1. This strict balancing ensures O(log n) operations by preventing the tree from becoming skewed.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "1",
    "options": [
      "0",
      "1",
      "log n",
      "2"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Trees",
    "subtopic": "B-Trees",
    "question": "In a B-Tree of order m, what is the minimum number of children a non-leaf internal node can have?",
    "context": "B-Trees maintain balance by ensuring each internal node (except root) has at least ⌈m/2⌉ children and at most m children. This property guarantees that the tree remains balanced and provides efficient search, insertion, and deletion operations in O(log n) time.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "⌈m/2⌉",
    "options": [
      "m-1",
      "⌈m/2⌉",
      "⌊m/2⌋",
      "m"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Heaps",
    "subtopic": "Binary Heap",
    "question": "What is the time complexity of building a binary heap from an unsorted array of n elements using the bottom-up approach?",
    "context": "Building a heap using bottom-up heapify starts from the last non-leaf node and applies heapify operation. The total work done is bounded by the sum of heights of all nodes, which equals O(n) due to the geometric series where most nodes are at lower levels.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O(n)",
    "options": [
      "O(n)",
      "O(n log n)",
      "O(log n)",
      "O(n²)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Stacks",
    "question": "Which data structure follows the Last-In-First-Out (LIFO) principle for element access?",
    "context": "A stack is a linear data structure that allows insertion and deletion only at one end, following the LIFO principle.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Stack",
    "options": [
      "Queue",
      "Linked List",
      "Stack",
      "Heap"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Linked Lists",
    "question": "Which operation is more efficient in a singly linked list compared to an array?",
    "context": "Linked lists allow constant time insertion at the beginning, unlike arrays that require shifting elements.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Insertion at the beginning",
    "options": [
      "Insertion at the beginning",
      "Random access",
      "Sorting",
      "Binary search"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Queues",
    "question": "Which data structure allows insertion at one end and deletion at the other end?",
    "context": "A queue operates in FIFO (First-In-First-Out) order, where insertion happens at the rear and deletion at the front.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Queue",
    "options": [
      "Queue",
      "Array",
      "Heap",
      "Stack"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Binary Search Trees",
    "question": "What is the worst-case time complexity of searching in an unbalanced Binary Search Tree?",
    "context": "In an unbalanced BST, the tree can degrade to a linked list in the worst case, leading to O(n) search time.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O(n)",
    "options": [
      "O(n log n)",
      "O(log n)",
      "O(1)",
      "O(n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "AVL Trees",
    "question": "Which type of binary tree ensures that the height difference between left and right subtrees is at most one?",
    "context": "AVL Trees are self-balancing binary search trees where the difference in height of subtrees is restricted to 1.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "AVL Tree",
    "options": [
      "B-Tree",
      "AVL Tree",
      "Binary Search Tree",
      "Red-Black Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Heaps",
    "question": "Which heap property must a max-heap maintain?",
    "context": "A max-heap is a complete binary tree where the value of each parent node is greater than or equal to its children.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Every parent node is greater than or equal to its children",
    "options": [
      "Each child is greater than its parent",
      "All nodes are sorted",
      "Every parent node is greater than or equal to its children",
      "Only leaf nodes have values"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "B-Trees",
    "question": "Which tree data structure is commonly used in databases and file systems to handle large amounts of data efficiently?",
    "context": "B-Trees are balanced search trees optimized for systems that read and write large blocks of data, like databases.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "B-Tree",
    "options": [
      "B-Tree",
      "Heap",
      "Segment Tree",
      "AVL Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "Which technique is commonly used in hashing to resolve collisions by placing the new item in the next available bucket?",
    "context": "Linear probing is a collision resolution technique in open addressing where the next slot is checked sequentially.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Linear Probing",
    "options": [
      "Separate Addressing",
      "Chaining",
      "Double Hashing",
      "Linear Probing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "In open addressing, which method uses a second hash function to calculate the interval between probes?",
    "context": "Double hashing reduces clustering by using a second hash function to calculate the probe step in open addressing.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Double Hashing",
    "options": [
      "Chaining",
      "Quadratic Probing",
      "Double Hashing",
      "Linear Probing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "What is the main advantage of using chaining to handle collisions in a hash table?",
    "context": "Chaining uses linked lists to store multiple values at a single hash index, effectively handling collisions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "It allows multiple elements to exist at the same index using linked lists",
    "options": [
      "It avoids using extra memory",
      "It sorts the elements automatically",
      "It allows multiple elements to exist at the same index using linked lists",
      "It reduces hash computations"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "Which graph representation uses less space for sparse graphs?",
    "context": "Adjacency lists are space-efficient for sparse graphs because they store only existing edges per vertex.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Adjacency List",
    "options": [
      "Adjacency List",
      "Adjacency Matrix",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "Which representation allows constant-time edge existence checks but takes O(V^2) space?",
    "context": "Adjacency matrices provide O(1) time edge lookup but require O(V²) space even for sparse graphs.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Adjacency Matrix",
    "options": [
      "Adjacency List",
      "Edge List",
      "Hash Table",
      "Adjacency Matrix"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "Which graph representation explicitly lists all edges as vertex pairs?",
    "context": "An edge list stores all edges as pairs of vertices, making it simple but less efficient for adjacency queries.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Edge List",
    "options": [
      "Weight Matrix",
      "Adjacency Matrix",
      "Adjacency List",
      "Edge List"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Hashing",
    "subtopic": "Hash Functions",
    "question": "What is the expected time complexity of search operation in a hash table with good hash function and proper load factor?",
    "context": "A hash table with a good hash function distributes keys uniformly across buckets, and maintaining proper load factor ensures minimal collisions. Under these conditions, the average case time complexity for search, insert, and delete operations is O(1) constant time.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(1)",
    "options": [
      "O(n)",
      "O(1)",
      "O(log n)",
      "O(n log n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Hashing",
    "subtopic": "Collision Resolution",
    "question": "In linear probing collision resolution, what is the primary disadvantage that affects performance?",
    "context": "Linear probing suffers from primary clustering where consecutive occupied slots form clusters. When a collision occurs, the probe sequence examines consecutive slots, causing items to cluster together and increasing the average probe distance for future operations.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Primary clustering",
    "options": [
      "Higher memory overhead",
      "Secondary clustering",
      "Infinite loops during insertion",
      "Primary clustering"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Hashing",
    "subtopic": "Double Hashing",
    "question": "In double hashing, what condition must the second hash function h2(k) satisfy to ensure all table positions are probed?",
    "context": "Double hashing uses probe sequence h1(k) + i×h2(k) mod m. For this sequence to visit all table positions before repeating, h2(k) and table size m must be relatively prime (gcd(h2(k), m) = 1), ensuring the probe sequence has period m.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "h2(k) must be relatively prime to table size",
    "options": [
      "h2(k) must be even",
      "h2(k) must be greater than h1(k)",
      "h2(k) must be relatively prime to table size",
      "h2(k) must be a power of 2"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Representations",
    "subtopic": "Adjacency Matrix",
    "question": "What is the space complexity of representing a graph with V vertices using an adjacency matrix?",
    "context": "An adjacency matrix is a V×V matrix where entry (i,j) indicates whether there is an edge between vertices i and j. Regardless of the actual number of edges E in the graph, the matrix always requires V² space to store all possible vertex pairs.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "O(V²)",
    "options": [
      "O(V²)",
      "O(V + E)",
      "O(V)",
      "O(E)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Representations",
    "subtopic": "Adjacency List",
    "question": "For a sparse graph with V vertices and E edges, which representation is more space-efficient?",
    "context": "Adjacency list uses O(V + E) space by maintaining a list of neighbors for each vertex. For sparse graphs where E << V², this is significantly more space-efficient than adjacency matrix's O(V²) space, especially when E is much smaller than V².",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Adjacency List",
    "options": [
      "Adjacency Matrix",
      "Adjacency List",
      "Edge List",
      "Incidence Matrix"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Representations",
    "subtopic": "Incidence Matrix",
    "question": "In an incidence matrix representation of a graph with V vertices and E edges, what are the dimensions of the matrix?",
    "context": "An incidence matrix has V rows (one for each vertex) and E columns (one for each edge). Entry (i,j) is 1 if vertex i is incident to edge j, and 0 otherwise. This representation explicitly shows the relationship between vertices and edges.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "V × E",
    "options": [
      "V × E",
      "E × V",
      "E × E",
      "V × V"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "Which technique is used in hashing to resolve collisions by storing multiple elements in the same slot using a linked list?",
    "context": "Chaining resolves hash collisions by maintaining a linked list at each hash table slot, allowing multiple elements to be stored at the same index with O(1) average-case insertion time.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Chaining",
    "options": [
      "Open Addressing",
      "Double Hashing",
      "Chaining",
      "Linear Probing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "Which graph representation is most suitable for a dense graph with V vertices and E edges?",
    "context": "An Adjacency Matrix uses a VxV matrix to represent a graph, requiring O(V^2) space, making it efficient for dense graphs where the number of edges is close to V^2.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Adjacency Matrix",
    "options": [
      "Adjacency Matrix",
      "Incidence Matrix",
      "Edge List",
      "Adjacency List"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "What is the time complexity of searching for an element in a hash table with a good hash function and no collisions?",
    "context": "With a good hash function and no collisions, a hash table achieves O(1) average-case time complexity for search operations due to direct index mapping.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O(1)",
    "options": [
      "O(1)",
      "O(log n)",
      "O(n log n)",
      "O(n)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "Which graph representation is most efficient for checking if an edge exists between two vertices in constant time?",
    "context": "An Adjacency Matrix allows checking for an edge between two vertices in O(1) time by accessing the matrix element at [u][v], unlike other representations which may require iteration.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Adjacency Matrix",
    "options": [
      "Incidence Matrix",
      "Adjacency Matrix",
      "Edge List",
      "Adjacency List"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "Which hashing technique uses a second hash function to resolve collisions by probing at intervals determined by the second hash value?",
    "context": "Double Hashing uses a second hash function to compute the step size for probing, reducing clustering and achieving better distribution of elements in the hash table.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Double Hashing",
    "options": [
      "Chaining",
      "Linear Probing",
      "Double Hashing",
      "Quadratic Probing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "Which graph representation is most space-efficient for a sparse graph with V vertices and E edges?",
    "context": "An Adjacency List uses O(V + E) space, making it ideal for sparse graphs where the number of edges is much less than V^2, as it only stores the actual edges.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Adjacency List",
    "options": [
      "Edge List",
      "Adjacency Matrix",
      "Incidence Matrix",
      "Adjacency List"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "A software development team is building a high-performance in-memory cache for a web application where frequent lookups of key-value pairs are critical. Which technique for handling collisions in a hash table typically offers the best cache performance due to better cache locality?",
    "context": "Open Addressing collision resolution techniques (like linear or quadratic probing) store all elements directly within the hash table's array. This often leads to better cache performance because data elements are stored contiguously in memory, reducing cache misses during lookups compared to Separate Chaining which uses linked lists (or other data structures) external to the main array.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Open Addressing (e.g., Linear Probing, Quadratic Probing)",
    "options": [
      "Separate Chaining",
      "Cuckoo Hashing",
      "Open Addressing (e.g., Linear Probing, Quadratic Probing)",
      "Perfect Hashing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Hashing",
    "question": "A system requires storing a very large set of IP addresses and performing extremely fast lookups to check if an IP address has been seen before. Given potential memory constraints, which hashing-related data structure might be suitable for approximating membership testing with a small probability of false positives?",
    "context": "A Bloom Filter is a probabilistic data structure that can test whether an element is a member of a set. It uses multiple hash functions to set bits in a bit array. While it can produce false positives (claiming an element is present when it's not), it guarantees no false negatives and is highly memory-efficient for large datasets, making it suitable for approximate membership testing.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Bloom Filter",
    "options": [
      "Bloom Filter",
      "Balanced Binary Search Tree",
      "Hash Map (Separate Chaining)",
      "Hash Table (Open Addressing)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Graph Representations",
    "question": "In a social network application, users and their friendships are represented as a graph. If the application frequently needs to list all friends of a particular user (i.e., find all neighbors of a vertex), which graph representation would be most efficient for this operation?",
    "context": "An Adjacency List represents a graph as an array of lists, where each `array[i]` contains a list of all vertices adjacent to vertex 'i'. This representation is highly efficient for sparse graphs (where the number of edges is much less than $|V|^2$) and for iterating through all neighbors of a specific vertex, as it only stores existing edges.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Adjacency List",
    "options": [
      "Adjacency List",
      "Incidence Matrix",
      "Edge List",
      "Adjacency Matrix"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Hashing",
    "subtopic": "Hash Function Properties",
    "question": "When designing a hash function for a critical system, what is the primary goal to ensure an even distribution of keys across the hash table and minimize collisions?",
    "context": "A good hash function aims to distribute keys as uniformly as possible across the hash table's address space. This uniform distribution minimizes the number of collisions, which in turn leads to better average-case performance for hash table operations (insertion, deletion, lookup). While cryptographic security and fixed-size output are properties of some hash functions, the primary goal for general hash table performance is collision minimization through uniform distribution.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Minimizing collisions and distributing keys uniformly.",
    "options": [
      "Minimizing collisions and distributing keys uniformly.",
      "Ensuring the hash function is cryptographically secure.",
      "Making the hash function computationally expensive.",
      "Producing fixed-size hash values regardless of input size."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Data Structures",
    "subtopic": "Graph Representations",
    "question": "A software engineer is working on a pathfinding algorithm for a game. The game world can be modeled as a graph, and due to frequent additions and removals of obstacles (edges), the graph structure changes dynamically. Which graph representation offers the best flexibility for adding and removing edges efficiently?",
    "context": "An Adjacency List is preferred when a graph is sparse and undergoes frequent modifications (additions or removals of edges). Adding or removing an edge in an Adjacency List typically involves modifying a linked list (or dynamic array) associated with a vertex, which can be done in O(degree(vertex)) or amortized O(1) time. In contrast, an Adjacency Matrix requires updating a specific cell, which is fast, but resizing the matrix for changing vertex counts can be costly, and for sparse graphs, it wastes memory.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Adjacency List",
    "options": [
      "Incidence Matrix",
      "2D Array",
      "Adjacency List",
      "Adjacency Matrix"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Regular Languages & Finite Automata",
    "question": "A network protocol is designed to accept only sequences of '0's and '1's that do not contain the substring '11'. Which type of automaton is precisely capable of recognizing all and only such valid sequences?",
    "context": "Regular languages are precisely those languages that can be recognized by Finite Automata (both DFA and NFA). The language of strings that do not contain a specific substring is a classic example of a regular language, for which a DFA can be constructed to keep track of the last few characters seen.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Deterministic Finite Automaton (DFA)",
    "options": [
      "Pushdown Automaton (PDA)",
      "Deterministic Finite Automaton (DFA)",
      "Linear Bounded Automaton (LBA)",
      "Turing Machine"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Regular Languages & Finite Automata",
    "question": "In the context of compiler design, lexical analysis (tokenization) is the phase that breaks source code into a stream of tokens. Which theoretical model is most directly applied to define and recognize the patterns of these tokens (like identifiers, keywords, and operators)?",
    "context": "Lexical analysis is fundamentally based on regular languages, which are formally described by regular expressions. Finite Automata are the computational models that implement the recognition of these regular expressions, effectively scanning the input and producing tokens based on defined patterns.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Regular Expressions and Finite Automata",
    "options": [
      "Turing Machines",
      "Regular Expressions and Finite Automata",
      "Lambda Calculus",
      "Context-Free Grammars"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Context-Free Grammars & Pushdown Automata",
    "question": "A programming language requires matching opening and closing parentheses, brackets, and braces. Which type of grammar is necessary to formally describe such a language feature, and what automaton can recognize it?",
    "context": "Languages requiring arbitrary nesting, like balanced parentheses, cannot be recognized by finite automata because they lack memory to count and match nested structures. Context-Free Grammars, with their recursive rules, are suitable for describing such nested structures, and Pushdown Automata (which use a stack) are precisely the computational model capable of recognizing Context-Free Languages.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Context-Free Grammar (CFG) and Pushdown Automaton (PDA)",
    "options": [
      "Context-Sensitive Grammar and Linear Bounded Automaton",
      "Unrestricted Grammar and Turing Machine",
      "Context-Free Grammar (CFG) and Pushdown Automaton (PDA)",
      "Regular Grammar and Finite Automaton"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Context-Free Grammars & Pushdown Automata",
    "question": "In a compiler's parsing phase, the syntax of a program is checked against a set of rules. For languages with recursive structures like nested function calls and arithmetic expressions, which formal system is used to define the syntax and what automaton type handles its recognition?",
    "context": "Context-Free Grammars are the standard formal tool for defining the syntax (grammatical structure) of programming languages. Features like nested expressions, function calls, and block structures exhibit context-free properties. Pushdown Automata, with their stack memory, are precisely designed to parse and recognize languages described by CFGs.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Context-Free Grammars (CFGs) for syntax definition, and Pushdown Automata (PDAs) for recognition.",
    "options": [
      "Turing Machines for syntax definition, and their variants for recognition.",
      "Context-Free Grammars (CFGs) for syntax definition, and Pushdown Automata (PDAs) for recognition.",
      "Regular Expressions for syntax definition, and Finite Automata for recognition.",
      "Context-Sensitive Grammars for syntax definition, and Linear Bounded Automata for recognition."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "A software engineer is asked to develop an algorithm that can determine if an arbitrary C++ program will eventually halt or run forever. Based on the theory of computation, what is the fundamental limitation encountered here, and what theoretical model demonstrates this?",
    "context": "The Halting Problem states that there is no general algorithm that can determine, for any arbitrary program and input, whether that program will eventually halt or continue to run forever. This fundamental undecidability was proven by Alan Turing using the Turing Machine model, which represents the most powerful model of computation.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "The Halting Problem is undecidable, as proven by the Turing Machine model.",
    "options": [
      "This problem is NP-complete, meaning it has no polynomial-time solution.",
      "The Halting Problem is undecidable, as proven by the Turing Machine model.",
      "This problem can be solved by a Deterministic Finite Automaton.",
      "This problem can be solved by a Pushdown Automaton."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "What is the most powerful model of computation in the Chomsky Hierarchy, capable of recognizing any language that can be generated by an unrestricted grammar, and which encompasses all computable functions?",
    "context": "The Turing Machine is considered the most powerful model of computation in the Chomsky Hierarchy. It can simulate any algorithm and is capable of recognizing all recursively enumerable languages (Type-0 languages), which are generated by unrestricted grammars. This universality is a cornerstone of theoretical computer science.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Turing Machine",
    "options": [
      "Pushdown Automaton (PDA)",
      "Finite Automaton (FA)",
      "Linear Bounded Automaton (LBA)",
      "Turing Machine"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Regular Languages & Finite Automata",
    "question": "Consider a system that processes network packets, and it needs to validate if a packet ID follows a specific format: exactly three alphanumeric characters followed by a hyphen, then exactly two digits. Which formal language concept is used to describe such patterns, and what automaton can recognize it?",
    "context": "The described packet ID format (fixed length, specific character types) is a classic example of a pattern that can be precisely defined using a regular expression. Regular expressions are used to describe regular languages, which are exactly the set of languages that can be recognized by Finite Automata (either DFA or NFA).",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Regular Expression, recognized by a Finite Automaton.",
    "options": [
      "Context-Free Grammar, recognized by a Pushdown Automaton.",
      "Turing Machine description, recognized by a Universal Turing Machine.",
      "Chomsky Normal Form, recognized by a Context-Sensitive Automaton.",
      "Regular Expression, recognized by a Finite Automaton."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Regular Languages",
    "question": "Which type of automaton accepts regular languages?",
    "context": "A Finite Automaton, either deterministic (DFA) or nondeterministic (NFA), accepts regular languages, which can be described by regular expressions and have a finite number of states.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Finite Automaton",
    "options": [
      "Turing Machine",
      "Finite Automaton",
      "Linear Bounded Automaton",
      "Pushdown Automaton"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Regular Languages",
    "question": "Which property of regular languages ensures that the union of two regular languages is also a regular language?",
    "context": "Regular languages are closed under union, meaning that if L1 and L2 are regular languages, their union L1 ∪ L2 can also be recognized by a finite automaton.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Closure under Union",
    "options": [
      "Closure under Union",
      "Closure under Concatenation",
      "Closure under Complement",
      "Closure under Intersection"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Context-Free Grammars",
    "question": "Which automaton is used to accept languages generated by context-free grammars?",
    "context": "A Pushdown Automaton (PDA) uses a stack to accept context-free languages, which are generated by context-free grammars, allowing it to handle nested structures like balanced parentheses.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Pushdown Automaton",
    "options": [
      "Pushdown Automaton",
      "Linear Bounded Automaton",
      "Finite Automaton",
      "Turing Machine"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Context-Free Grammars",
    "question": "Which normal form of context-free grammar ensures that all productions are of the form A → BC or A → a, where A, B, C are variables and a is a terminal?",
    "context": "Chomsky Normal Form (CNF) transforms a context-free grammar so that each production is either of the form A → BC (two variables) or A → a (a terminal), simplifying parsing algorithms.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Chomsky Normal Form",
    "options": [
      "Backus-Naur Form",
      "Greibach Normal Form",
      "Chomsky Normal Form",
      "Kuroda Normal Form"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Finite Automata",
    "question": "Which type of finite automaton can have multiple possible transitions for the same input symbol from a given state?",
    "context": "A Nondeterministic Finite Automaton (NFA) allows multiple transitions for the same input symbol and may include epsilon transitions, but it is equivalent in power to a DFA for recognizing regular languages.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Nondeterministic Finite Automaton",
    "options": [
      "Pushdown Automaton",
      "Nondeterministic Finite Automaton",
      "Epsilon-NFA",
      "Deterministic Finite Automaton"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "Which machine is capable of deciding any recursively enumerable language?",
    "context": "A Turing Machine is a computational model that can recognize recursively enumerable languages by using an infinite tape and a read/write head, making it more powerful than finite or pushdown automata.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Turing Machine",
    "options": [
      "Pushdown Automaton",
      "Finite Automaton",
      "Linear Bounded Automaton",
      "Turing Machine"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "Which problem related to Turing Machines is known to be undecidable?",
    "context": "The Halting Problem, which determines whether a Turing Machine halts on a given input, is undecidable, meaning no general algorithm can solve it for all possible inputs.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Halting Problem",
    "options": [
      "Emptiness Problem",
      "Halting Problem",
      "Equivalence Problem",
      "Reachability Problem"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Regular Languages",
    "question": "Which of the following languages is NOT regular?",
    "context": "Regular languages can be recognized by finite automata which have finite memory. The language {a^n b^n | n ≥ 0} requires counting and matching equal numbers of a's and b's, which needs infinite memory to store the count, making it non-regular by the pumping lemma.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "L = {a^n b^n | n ≥ 0}",
    "options": [
      "L = {a^n b^n | n ≥ 0}",
      "L = {a^n | n ≥ 0}",
      "L = {strings over {a,b} ending with 'ab'}",
      "L = {strings over {a,b} with even number of a's}"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Finite Automata",
    "question": "What is the minimum number of states required in a DFA to accept strings over {0,1} that contain '101' as a substring?",
    "context": "A DFA needs states to track progress toward finding '101': initial state, after reading '1', after reading '10', and accepting state after reading '101'. The fourth state is needed because we must remember partial matches and handle overlapping patterns correctly.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "4",
    "options": [
      "4",
      "3",
      "5",
      "6"
    ]
  },
  {
    "goal": "GATE CSE",
    "subtopic": "Context-Free Grammars",
    "topic": "Theory of Computation",
    "question": "Which of the following is a characteristic property of Context-Free Languages?",
    "context": "Context-Free Languages are exactly those languages that can be generated by Context-Free Grammars and recognized by Pushdown Automata. They are not closed under intersection (unlike regular languages), and while they can be recognized by LBA, this is not their defining characteristic.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Can be generated by Context-Free Grammars",
    "options": [
      "Can be recognized by Finite Automata",
      "Can be generated by Context-Free Grammars",
      "Can be recognized by Linear Bounded Automata only",
      "Closed under intersection operation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Pushdown Automata",
    "question": "What additional component does a Pushdown Automaton have compared to a Finite Automaton?",
    "context": "A Pushdown Automaton extends a Finite Automaton by adding a stack, which provides Last-In-First-Out (LIFO) memory. This stack allows PDA to recognize context-free languages by storing and matching nested structures that finite automata cannot handle.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Stack (LIFO memory)",
    "options": [
      "Stack (LIFO memory)",
      "Queue (FIFO memory)",
      "Random access memory",
      "Multiple input tapes"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Context-Free Grammar Parsing",
    "question": "What is the time complexity of the CYK (Cocke-Younger-Kasami) algorithm for parsing context-free grammars?",
    "context": "The CYK algorithm uses dynamic programming with a triangular table of size O(n²) where each cell requires O(n) time to compute by checking all possible ways to split a substring. This results in O(n³) time complexity for parsing strings of length n.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "O(n³)",
    "options": [
      "O(n)",
      "O(n²)",
      "O(n log n)",
      "O(n³)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "Which of the following problems is undecidable for Turing Machines?",
    "context": "The Halting Problem asks whether a given Turing Machine halts on a given input. This problem is undecidable, proven by contradiction using diagonalization. The other problems are decidable: regular language membership is decidable by DFA simulation, DFA equivalence by state minimization, and CFG emptiness by reachability analysis.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Halting Problem",
    "options": [
      "Emptiness problem for context-free languages",
      "Halting Problem",
      "Membership problem for regular languages",
      "Equivalence of two DFAs"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machine Variants",
    "question": "Which statement about Turing Machine variants is correct?",
    "context": "All reasonable variants of Turing Machines (multi-tape, multi-head, two-way infinite tape, non-deterministic) have equivalent computational power. They can simulate each other with at most polynomial time overhead, defining the same class of decidable languages and maintaining the Church-Turing thesis.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Multi-tape Turing Machines have the same computational power as single-tape Turing Machines",
    "options": [
      "Multi-head Turing Machines can solve undecidable problems",
      "Non-deterministic Turing Machines are more powerful than deterministic ones",
      "Two-way infinite tape Turing Machines are more powerful than one-way infinite tape",
      "Multi-tape Turing Machines have the same computational power as single-tape Turing Machines"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Finite Automata",
    "question": "Which class of languages can be recognized by a finite automaton?",
    "context": "Finite automata are theoretical machines that recognize regular languages, which can be described using regular expressions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Regular Languages",
    "options": [
      "Context-Free Languages",
      "Recursive Languages",
      "Regular Languages",
      "Context-Sensitive Languages"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Finite Automata",
    "question": "Which of the following operations is closed under regular languages?",
    "context": "Regular languages are closed under operations like union, concatenation, and Kleene star.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Union",
    "options": [
      "Subset Construction",
      "Intersection with Context-Free Language",
      "Union",
      "Palindrome"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Pushdown Automata",
    "question": "Which class of languages is recognized by Pushdown Automata?",
    "context": "Pushdown automata use a stack to recognize context-free languages which cannot be accepted by finite automata.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Context-Free Languages",
    "options": [
      "Context-Sensitive Languages",
      "Regular Languages",
      "Recursive Languages",
      "Context-Free Languages"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Context-Free Grammars",
    "question": "Which type of grammar generates languages that can be recognized by Pushdown Automata?",
    "context": "Context-Free Grammars (CFGs) are used to generate context-free languages that are accepted by pushdown automata.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Context-Free Grammar",
    "options": [
      "Unrestricted Grammar",
      "Regular Grammar",
      "Context-Free Grammar",
      "Context-Sensitive Grammar"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "Which model of computation is capable of simulating any algorithm?",
    "context": "Turing Machines are the most powerful models of computation and can simulate any algorithmic process.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Turing Machine",
    "options": [
      "Finite Automaton",
      "Pushdown Automaton",
      "Turing Machine",
      "Stack Machine"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "What type of language is accepted by a Turing Machine that always halts?",
    "context": "Turing Machines that always halt accept recursive languages, which are decidable.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Recursive Language",
    "options": [
      "Context-Free Language",
      "Recursive Language",
      "Regular Language",
      "Recursively Enumerable Language"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Turing Machines",
    "question": "Which class of languages can be recognized by a Turing Machine but not necessarily decided?",
    "context": "Recursively enumerable languages are accepted by Turing Machines, but the machine may not halt for some inputs.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Recursively Enumerable Languages",
    "options": [
      "Recursively Enumerable Languages",
      "Recursive Languages",
      "Context-Free Languages",
      "Regular Languages"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability",
    "question": "Which of the following problems is **decidable**?",
    "context": "The problem of checking if a DFA accepts a string is decidable because it can be determined by simulating the DFA.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Whether a DFA accepts a given string",
    "options": [
      "Whether a TM accepts all strings",
      "Whether a CFG generates all strings",
      "Whether a DFA accepts a given string",
      "Whether a Turing machine halts on all inputs"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability",
    "question": "Which problem is an example of an undecidable problem?",
    "context": "The halting problem is a classic example of an undecidable problem where it is not possible to determine if a TM halts on all inputs.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Halting Problem for Turing Machines",
    "options": [
      "Equivalence of two DFAs",
      "Halting Problem for Turing Machines",
      "Grammar ambiguity checking for regular grammar",
      "Membership in a regular language"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Undecidability",
    "question": "Which of the following is **undecidable** even when given a context-free grammar?",
    "context": "Determining ambiguity in a context-free grammar is undecidable due to the infinite ways a string might be parsed.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Ambiguity of a context-free grammar",
    "options": [
      "Whether the grammar generates finite language",
      "Ambiguity of a context-free grammar",
      "Whether a string is generated by the grammar",
      "Whether the language is empty"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P vs NP",
    "question": "Which of the following best describes problems in class P?",
    "context": "Class P consists of decision problems solvable by deterministic Turing machines in polynomial time.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Problems solvable in polynomial time by a deterministic machine",
    "options": [
      "Problems solvable in exponential time",
      "Problems solvable using Turing reductions",
      "Problems verifiable in linear time",
      "Problems solvable in polynomial time by a deterministic machine"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "NP-Completeness",
    "question": "What does it mean if a problem is NP-complete?",
    "context": "NP-complete problems are the hardest problems in NP, meaning if one is solved in P, all NP problems are solvable in P.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "It is in NP and every problem in NP can be reduced to it in polynomial time",
    "options": [
      "It is undecidable",
      "It is harder than all problems in P",
      "It can be solved in constant time",
      "It is in NP and every problem in NP can be reduced to it in polynomial time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P vs NP",
    "question": "Which of the following statements is currently true about the P vs NP problem?",
    "context": "The question of whether every problem whose solution can be quickly verified can also be quickly solved remains unanswered.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "It is unknown whether P = NP or not",
    "options": [
      "It is unknown whether P = NP or not",
      "NP-complete problems can be solved in linear time",
      "NP problems are always harder than P",
      "P is a subset of NP-complete"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability",
    "question": "Which of the following problems is decidable for context-free languages?",
    "context": "The emptiness problem for context-free languages asks whether a CFG generates any string. This is decidable by checking if the start symbol can derive any terminal string using reachability analysis. However, equivalence, intersection, and universality problems are undecidable for CFLs.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Emptiness problem",
    "options": [
      "Intersection problem",
      "Universality problem",
      "Equivalence problem",
      "Emptiness problem"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Undecidability",
    "question": "Which technique is commonly used to prove that a problem is undecidable?",
    "context": "To prove undecidability, we typically use reduction: if problem A is known to be undecidable and we can reduce A to problem B, then B must also be undecidable. This technique shows that solving B would imply solving A, which is impossible since A is undecidable.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Reduction from a known undecidable problem",
    "options": [
      "Mathematical induction",
      "Reduction from a known undecidable problem",
      "Proof by contradiction only",
      "Direct construction of algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Rice's Theorem",
    "question": "According to Rice's Theorem, which type of properties of Turing Machine languages are undecidable?",
    "context": "Rice's Theorem states that every non-trivial semantic property of the language recognized by Turing machines is undecidable. A property is non-trivial if some TM languages have it and some don't. Semantic properties depend on the language itself, not the machine's structure.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "All non-trivial semantic properties",
    "options": [
      "All syntactic properties",
      "Only properties about machine structure",
      "All non-trivial semantic properties",
      "Properties that depend on input alphabet size"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Complexity Theory",
    "subtopic": "P vs NP",
    "question": "Which statement correctly describes the complexity class P?",
    "context": "The complexity class P consists of decision problems that can be solved by a deterministic Turing machine in polynomial time. This includes problems where there exists an algorithm with time complexity O(n^k) for some constant k, representing efficiently solvable problems.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Languages decidable by deterministic TM in polynomial time",
    "options": [
      "Languages decidable by deterministic TM in polynomial time",
      "Languages verifiable in polynomial time",
      "Languages decidable in exponential time",
      "Languages decidable by non-deterministic TM in polynomial time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Complexity Theory",
    "subtopic": "NP-Complete Problems",
    "question": "Which property must a problem satisfy to be classified as NP-complete?",
    "context": "A problem is NP-complete if it belongs to NP (verifiable in polynomial time) and is NP-hard (every problem in NP can be reduced to it in polynomial time). This means it's among the hardest problems in NP, and solving any NP-complete problem efficiently would solve all NP problems efficiently.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Must be in NP and every NP problem reduces to it",
    "options": [
      "Must be undecidable",
      "Must be in NP and every NP problem reduces to it",
      "Must be in P and solvable in polynomial time",
      "Must be harder than all problems in NP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Complexity Theory",
    "subtopic": "NP-Complete Examples",
    "question": "Which of the following is a well-known NP-complete problem?",
    "context": "3-SAT is NP-complete where each clause has exactly 3 literals. It was one of the first problems proven NP-complete using Cook's theorem. In contrast, 2-SAT is in P (solvable in polynomial time), Linear Programming is in P using interior point methods, and Shortest Path is in P using Dijkstra's algorithm.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "3-SAT (3-Satisfiability)",
    "options": [
      "2-SAT (2-Satisfiability)",
      "Shortest Path Problem",
      "Linear Programming",
      "3-SAT (3-Satisfiability)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability",
    "question": "Which problem for a Turing Machine is decidable?",
    "context": "The Membership Problem for Regular Languages is decidable because a Turing Machine can simulate a finite automaton to determine if a string belongs to the language in finite time.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Membership Problem for Regular Languages",
    "options": [
      "Emptiness Problem for Context-Free Languages",
      "Membership Problem for Regular Languages",
      "Halting Problem",
      "Equivalence Problem for Context-Sensitive Languages"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P and NP",
    "question": "Which complexity class contains problems that can be solved by a deterministic Turing Machine in polynomial time?",
    "context": "Class P includes problems solvable in polynomial time by a deterministic Turing Machine, such as sorting or matrix multiplication, with time complexity bounded by a polynomial in input size.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "P",
    "options": [
      "EXP",
      "P",
      "NP",
      "NP-complete"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Undecidability",
    "question": "Which problem is known to be undecidable for general Turing Machines?",
    "context": "The Halting Problem, determining whether a Turing Machine halts on a given input, is undecidable as no general algorithm can solve it for all inputs in finite time.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Halting Problem",
    "options": [
      "Membership Problem for Finite Automata",
      "Halting Problem",
      "Sorting an Array",
      "Reachability in Graphs"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "NP-completeness",
    "question": "Which problem is a well-known example of an NP-complete problem involving finding a satisfying assignment for a Boolean formula?",
    "context": "The Satisfiability (SAT) Problem, determining if a Boolean formula has a satisfying assignment, is NP-complete, serving as a foundation for proving other problems are NP-complete.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "SAT Problem",
    "options": [
      "SAT Problem",
      "Shortest Path Problem",
      "Matrix Chain Multiplication",
      "Minimum Spanning Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P and NP",
    "question": "Which statement is true about the relationship between P, NP, and NP-complete problems?",
    "context": "P is a subset of NP because any problem solvable in polynomial time by a deterministic Turing Machine can also be verified in polynomial time, but the reverse is not necessarily true.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "P ⊆ NP",
    "options": [
      "NP ⊆ P",
      "All NP problems are NP-complete",
      "P ⊆ NP",
      "P = NP-complete"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "NP-completeness",
    "question": "Which property must a problem satisfy to be classified as NP-complete?",
    "context": "An NP-complete problem must be in NP (verifiable in polynomial time) and NP-hard (at least as hard as the hardest problems in NP), making it a candidate for polynomial-time reductions.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "It is in NP and NP-hard",
    "options": [
      "It is in P and undecidable",
      "It is in NP and decidable",
      "It is in NP and NP-hard",
      "It is in P and NP-hard"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability and Undecidability",
    "question": "A software company is developing a static analysis tool to find all possible runtime errors (e.g., division by zero, null pointer dereferences) in any given arbitrary C++ program. Based on the theory of computation, what fundamental limitation does this task face?",
    "context": "The problem of determining whether an arbitrary program will exhibit a specific runtime error (like the Halting Problem, but for other properties) is generally undecidable. This means no single algorithm can always correctly predict all such errors for all possible programs, a limitation inherent to the nature of computation as modeled by Turing Machines.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "It is an undecidable problem, meaning no algorithm can reliably determine all runtime errors for all programs.",
    "options": [
      "It is an undecidable problem, meaning no algorithm can reliably determine all runtime errors for all programs.",
      "It is a decidable problem, solvable with an efficient algorithm.",
      "It is a P-class problem, solvable in polynomial time.",
      "It is an NP-complete problem, requiring exponential time to find a solution."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability and Undecidability",
    "question": "In the context of formal languages, which of the following properties of regular languages is known to be decidable?",
    "context": "For regular languages, many problems are decidable. For instance, determining if a regular language is empty can be done by checking if any accepting state is reachable from the start state in its corresponding Finite Automaton. In contrast, the equivalence and ambiguity problems for Context-Free Grammars, and the Post Correspondence Problem, are known to be undecidable.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "The emptiness problem (Is the language empty?).",
    "options": [
      "The ambiguity problem for context-free grammars.",
      "The equivalence problem for context-free grammars.",
      "The Post Correspondence Problem.",
      "The emptiness problem (Is the language empty?)."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P, NP, NP-completeness",
    "question": "A research team is attempting to find a polynomial-time algorithm for the Boolean Satisfiability Problem (SAT). If they succeed, what widely accepted implication would this have for the relationship between complexity classes P and NP?",
    "context": "SAT is a foundational NP-complete problem. If a polynomial-time algorithm is found for any NP-complete problem (like SAT), it would imply that every problem in NP can be solved in polynomial time, thus proving that P = NP. This is one of the most significant unsolved problems in computer science.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "P = NP, meaning all NP problems would have polynomial-time solutions.",
    "options": [
      "NP-complete problems would become undecidable.",
      "Only NP-hard problems would remain intractable.",
      "P = NP, meaning all NP problems would have polynomial-time solutions.",
      "P ≠ NP, reinforcing the current belief."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P, NP, NP-completeness",
    "question": "Which of the following problems is a classic example of an NP-complete problem, meaning it is in NP and is also NP-hard?",
    "context": "NP-complete problems are a set of problems that are both in NP (solutions can be verified in polynomial time) and are NP-hard (any problem in NP can be reduced to them in polynomial time). The Traveling Salesperson Problem, Vertex Cover, 3-SAT, and Subset Sum are well-known examples of NP-complete problems.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "The Traveling Salesperson Problem (TSP)",
    "options": [
      "The Traveling Salesperson Problem (TSP)",
      "Finding the shortest path in an unweighted graph (e.g., using BFS).",
      "Sorting an array of numbers.",
      "Searching for an element in a sorted list."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "Decidability and Undecidability",
    "question": "What is the crucial difference between a decidable problem and an undecidable problem in the context of computation?",
    "context": "The fundamental definition of decidability in theoretical computer science is whether an algorithm (a Turing machine) exists that can determine, for any given input, whether that input belongs to the language (or if the problem has a 'yes' or 'no' answer) and always halts. Undecidable problems lack such a universal algorithm.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "A decidable problem has an algorithm that always halts and provides a correct 'yes' or 'no' answer, while an undecidable problem does not.",
    "options": [
      "Decidable problems can be solved in polynomial time, while undecidable problems cannot.",
      "Decidable problems are only solved by Turing machines, while undecidable problems are not.",
      "A decidable problem has an algorithm that always halts and provides a correct 'yes' or 'no' answer, while an undecidable problem does not.",
      "Decidable problems have practical applications, while undecidable problems are purely theoretical."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Theory of Computation",
    "subtopic": "P, NP, NP-completeness",
    "question": "For a software engineer working on optimization problems, understanding the class P is vital. What defines a problem as belonging to the complexity class P?",
    "context": "The complexity class P consists of decision problems that can be solved by a deterministic Turing machine in polynomial time with respect to the input size. These are problems considered 'tractable' or 'efficiently solvable' in practice.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "It can be solved by a deterministic Turing machine in polynomial time.",
    "options": [
      "It requires exponential time to find an optimal solution.",
      "It can be solved by a deterministic Turing machine in polynomial time.",
      "Its solution can be verified in polynomial time by a non-deterministic Turing machine.",
      "It can only be solved by a non-deterministic Turing machine in polynomial time."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "Which phase of a compiler is responsible for removing white spaces and comments from the source code?",
    "context": "Lexical analysis is the first phase of a compiler where white spaces and comments are removed and tokens are generated.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Lexical Analyzer",
    "options": [
      "Lexical Analyzer",
      "Semantic Analyzer",
      "Code Generator",
      "Syntax Analyzer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "What is the output of the lexical analysis phase in a compiler?",
    "context": "Lexical analysis converts the input source code into a stream of tokens which are then fed into the parser.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Sequence of tokens",
    "options": [
      "Intermediate code",
      "Symbol table",
      "Sequence of tokens",
      "Parse tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing",
    "question": "Which of the following parsers uses a **bottom-up** approach?",
    "context": "LR parsers are bottom-up parsers which construct the parse tree from leaves to the root.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "LR Parser",
    "options": [
      "LR Parser",
      "LL Parser",
      "Recursive Descent Parser",
      "Predictive Parser"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing",
    "question": "Which parser uses **leftmost derivation in reverse**?",
    "context": "An LR parser performs a bottom-up parse which corresponds to a leftmost derivation in reverse.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "LR Parser",
    "options": [
      "LL Parser",
      "Top-Down Parser",
      "LR Parser",
      "SLR Parser"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing",
    "question": "Which parser is **predictive** and does not require backtracking?",
    "context": "LL(1) parsers are top-down parsers that can predict the parsing action with one lookahead symbol and no backtracking.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "LL(1) Parser",
    "options": [
      "LL(1) Parser",
      "LALR Parser",
      "SLR Parser",
      "LR(0) Parser"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "In syntax-directed translation, what is associated with grammar symbols to store intermediate information?",
    "context": "Attributes are associated with grammar symbols to evaluate semantic rules in syntax-directed translation.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Attributes",
    "options": [
      "Attributes",
      "Symbols",
      "Tokens",
      "Derivations"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "What defines how the values of attributes are computed in syntax-directed definitions?",
    "context": "Semantic rules define how attribute values are computed based on the attributes of related grammar symbols.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Semantic Rules",
    "options": [
      "Lookahead Sets",
      "Parse Tables",
      "Productions",
      "Semantic Rules"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "What is the primary function of a lexical analyzer in a compiler?",
    "context": "The lexical analyzer (scanner) is the first phase of compilation that reads the source program character by character and groups them into meaningful sequences called tokens (like keywords, identifiers, operators, literals). It removes whitespace and comments, preparing input for the syntax analyzer.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Convert source code into tokens",
    "options": [
      "Perform semantic analysis",
      "Convert source code into tokens",
      "Check syntax correctness of the program",
      "Generate intermediate code"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Regular Expressions",
    "question": "Which tool is commonly used to automatically generate lexical analyzers from regular expressions?",
    "context": "LEX (and its GNU version FLEX) is a lexical analyzer generator that takes regular expressions as input and produces C code for a lexical analyzer. It automates the process of converting regular expression patterns into finite automata for token recognition.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "LEX/FLEX",
    "options": [
      "ANTLR",
      "YACC/BISON",
      "LEX/FLEX",
      "LALR(1)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "LL Parsing",
    "question": "What condition must a grammar satisfy to be parsed by an LL(1) parser?",
    "context": "LL(1) parsers require grammars without left recursion (which causes infinite loops in top-down parsing) and without left factoring (which creates ambiguity in choosing production rules). The grammar must also satisfy the LL(1) condition where FIRST and FOLLOW sets don't overlap inappropriately.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "No left recursion and no left factoring",
    "options": [
      "No left recursion and no left factoring",
      "Must be ambiguous",
      "Must have shift-reduce conflicts",
      "Must be right recursive only"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "LR Parsing",
    "question": "Which type of LR parser can handle the largest class of context-free grammars?",
    "context": "Among LR parsers, CLR (Canonical LR) can handle the largest class of grammars, followed by LALR, then SLR. CLR uses the most precise lookahead information by maintaining separate lookahead sets for each item in different states, avoiding conflicts that might occur in LALR and SLR parsers.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Canonical LR (CLR)",
    "options": [
      "Simple LR (SLR)",
      "LL(1)",
      "Look-Ahead LR (LALR)",
      "Canonical LR (CLR)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Shift-Reduce Parsing",
    "question": "In LR parsing, what does a 'reduce' action represent?",
    "context": "In shift-reduce parsing, a reduce action occurs when the top of the stack contains a handle (right-hand side of a production). The parser reduces by popping the handle from the stack and pushing the corresponding left-hand side non-terminal, effectively applying a production rule in reverse.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Replace handle on stack top with non-terminal",
    "options": [
      "Replace handle on stack top with non-terminal",
      "Shift input symbol onto stack",
      "Report syntax error",
      "Accept the input string"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "In syntax-directed translation, when are semantic actions executed in an S-attributed grammar?",
    "context": "S-attributed grammars have semantic attributes that depend only on attributes of children nodes. In bottom-up parsing, semantic actions are executed when a reduction occurs, as all child attributes are already computed, allowing parent attributes to be calculated immediately.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "During bottom-up parsing after reduction",
    "options": [
      "After complete parse tree construction",
      "During bottom-up parsing after reduction",
      "Before parsing begins",
      "During top-down parsing before expansion"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Attribute Grammars",
    "question": "What is the main difference between synthesized and inherited attributes in attribute grammars?",
    "context": "In attribute grammars, synthesized attributes have values computed from attributes of child nodes and flow upward in the parse tree, while inherited attributes receive values from parent or sibling nodes and flow downward. This distinction determines the evaluation order and parsing strategy compatibility.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Synthesized flow from children to parent, inherited flow from parent to children",
    "options": [
      "Synthesized flow from children to parent, inherited flow from parent to children",
      "Synthesized handle errors, inherited handle semantics",
      "Synthesized are computed first, inherited are computed last",
      "Synthesized are for terminals, inherited are for non-terminals"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "Which component of a compiler is responsible for breaking the source code into tokens?",
    "context": "The Lexical Analyzer, or scanner, processes the source code character by character to produce a sequence of tokens, such as keywords, identifiers, and operators, for the parser to use.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Lexical Analyzer",
    "options": [
      "Semantic Analyzer",
      "Parser",
      "Lexical Analyzer",
      "Code Generator"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "Which tool is commonly used to generate a lexical analyzer from a set of regular expressions?",
    "context": "Lex is a tool that generates a lexical analyzer by converting regular expressions into a finite automaton, producing C code that tokenizes input for a compiler.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Lex",
    "options": [
      "Lex",
      "ANTLR",
      "Yacc",
      "Bison"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing",
    "question": "Which parsing technique constructs a parse tree top-down and requires a left-factored, unambiguous grammar?",
    "context": "LL Parsing builds the parse tree top-down, using a left-to-right scan and leftmost derivation, requiring the grammar to be left-factored and unambiguous to avoid conflicts.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "LL Parsing",
    "options": [
      "LL Parsing",
      "LR Parsing",
      "LALR Parsing",
      "SLR Parsing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing",
    "question": "Which parsing technique is more powerful and can handle a larger class of grammars by constructing the parse tree bottom-up?",
    "context": "LR Parsing constructs the parse tree bottom-up using a left-to-right scan and rightmost derivation, handling a broader class of grammars, including some ambiguous ones, with the help of a parsing table.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "LR Parsing",
    "options": [
      "Operator Precedence Parsing",
      "Recursive Descent Parsing",
      "LR Parsing",
      "LL Parsing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "Which attribute in Syntax-Directed Translation is computed using information from a node's children in the parse tree?",
    "context": "Synthesized Attributes are computed bottom-up in a parse tree, using values from a node's children, such as calculating the value of an expression from its sub-expressions.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Synthesized Attribute",
    "options": [
      "Inherited Attribute",
      "Terminal Attribute",
      "Semantic Attribute",
      "Synthesized Attribute"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing",
    "question": "Which type of LR parser uses a lookahead of one symbol and a simplified parsing table to handle a subset of LR(0) grammars?",
    "context": "An SLR (Simple LR) Parser uses a single lookahead symbol and constructs a simplified parsing table based on follow sets, handling a subset of LR(0) grammars efficiently but with less power than CLR or LALR parsers.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "SLR Parser",
    "options": [
      "LALR Parser",
      "LL(1) Parser",
      "CLR Parser",
      "SLR Parser"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "Which type of Syntax-Directed Translation evaluates attributes during a single depth-first traversal of the parse tree?",
    "context": "An S-attributed Definition uses only synthesized attributes, allowing evaluation in a single bottom-up, depth-first traversal of the parse tree, simplifying attribute computation in compilers.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "S-attributed Definition",
    "options": [
      "S-attributed Definition",
      "E-attributed Definition",
      "T-attributed Definition",
      "L-attributed Definition"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "During the compilation process, what is the primary role of the lexical analyzer, and which theoretical concept is typically used to define the patterns it recognizes?",
    "context": "Lexical analysis, also known as scanning or tokenization, is the first phase of a compiler. Its main job is to read the stream of characters in the source code and group them into meaningful units called tokens (e.g., keywords, identifiers, operators, literals). These token patterns are typically defined using regular expressions, and finite automata are used to recognize them.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To read source code characters and group them into tokens; Regular Expressions.",
    "options": [
      "To generate intermediate code; Syntax Trees.",
      "To check the grammatical structure of the program; Context-Free Grammars.",
      "To optimize the machine code; Control Flow Graphs.",
      "To read source code characters and group them into tokens; Regular Expressions."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Lexical Analysis",
    "question": "A compiler's lexical analyzer encounters a string like 'if_else_statement'. How would it typically process this sequence of characters if 'if' and 'else' are keywords, but 'if_else_statement' is intended as a single identifier?",
    "context": "Lexical analyzers typically follow the 'maximal munch' rule, meaning they try to form the longest possible valid token from the input stream. In this case, if 'if_else_statement' matches the pattern for an identifier, it will be taken as a single token, rather than breaking it down into smaller keywords, assuming identifier rules allow underscores.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "It would recognize 'if_else_statement' as a single identifier token.",
    "options": [
      "It would report a lexical error due to ambiguity.",
      "It would recognize 'if_else_statement' as a single identifier token.",
      "It would require backtracking to correctly identify the tokens.",
      "It would recognize 'if' as a keyword, then 'else' as a keyword, and then 'statement' as an identifier."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing (LL, LR parsers)",
    "question": "In the context of parsing, which type of parser builds a parse tree from the top (start symbol) down to the input string by applying grammar rules, and typically handles left recursion by transforming the grammar?",
    "context": "LL parsers are a type of top-down parser that try to derive the input string from the start symbol by applying grammar rules. They read the input from left to right and produce a leftmost derivation. A key characteristic is their inability to handle left recursion directly, requiring grammar transformation to remove it.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "LL Parser (Top-Down Parser)",
    "options": [
      "Shift-Reduce Parser",
      "Operator Precedence Parser",
      "LR Parser (Bottom-Up Parser)",
      "LL Parser (Top-Down Parser)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing (LL, LR parsers)",
    "question": "A new programming language needs a parser that can handle a wide range of grammars, including ambiguous ones (though typically resolved by rules), and is known for its power and ability to detect errors early. Which family of parsers is generally preferred for this purpose in practical compilers?",
    "context": "LR parsers are a powerful class of bottom-up parsers that are widely used in practical compilers. They are capable of parsing a large class of grammars, including most programming language grammars, and are known for their efficiency and early error detection. Different variants like SLR, LALR, and Canonical LR offer different levels of power and complexity.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "LR Parsers (e.g., SLR, LALR, Canonical LR)",
    "options": [
      "LL Parsers",
      "LR Parsers (e.g., SLR, LALR, Canonical LR)",
      "Precedence Parsers",
      "Recursive Descent Parsers"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "After parsing, a compiler needs to perform semantic analysis and generate intermediate code. Which technique integrates semantic actions with the parsing process to produce output based on the grammar's syntax, and often involves attribute grammars?",
    "context": "Syntax-Directed Translation (SDT) is a method of generating intermediate code or performing semantic analysis by associating semantic rules (actions) with grammar productions. When a production is recognized by the parser, its associated semantic actions are executed. Attribute grammars are a formal way to describe SDTs, using synthesized and inherited attributes to pass information through the parse tree.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Syntax-Directed Translation (SDT)",
    "options": [
      "Runtime Environment Setup",
      "Lexical Analysis",
      "Code Optimization",
      "Syntax-Directed Translation (SDT)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Syntax-Directed Translation",
    "question": "Consider a Syntax-Directed Definition (SDD) for evaluating arithmetic expressions. When computing the value of an expression like '3 + 5', where would the semantic action to perform the addition typically be placed in the grammar production to ensure correct evaluation during a bottom-up parse?",
    "context": "In Syntax-Directed Translation, especially with bottom-up parsing (like LR parsers), semantic actions are usually placed at the end of the right-hand side of a grammar production. This ensures that all necessary attributes (like the values of operands) have been computed by their respective sub-productions before the action requiring them (e.g., addition) is executed.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "After recognizing both operands and the '+' operator, at the end of the production rule for addition.",
    "options": [
      "After recognizing both operands and the '+' operator, at the end of the production rule for addition.",
      "Before recognizing any part of the expression.",
      "Immediately after recognizing the first operand.",
      "At the very beginning of the entire parsing process."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Parsing (LL, LR parsers)",
    "question": "What is the primary function of the 'lookahead' symbol in both LL and LR parsing techniques?",
    "context": "The lookahead symbol (or lookahead tokens) is a crucial concept in predictive parsing (LL) and shift-reduce parsing (LR). It refers to the next input symbol(s) that the parser examines without consuming, to make decisions about which grammar production to apply (in LL) or whether to shift or reduce (in LR), thus guiding the parsing process.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To decide which grammar production to use for expansion or reduction.",
    "options": [
      "To store previously processed tokens.",
      "To generate machine code directly.",
      "To perform semantic analysis.",
      "To decide which grammar production to use for expansion or reduction."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Intermediate Code Generation",
    "question": "Which of the following is commonly used as intermediate code in compilers?",
    "context": "Three Address Code (TAC) is widely used in intermediate code generation to simplify analysis and optimization.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Three Address Code",
    "options": [
      "Source Code",
      "Machine Code",
      "Three Address Code",
      "Assembly Code"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Intermediate Code Generation",
    "question": "What is the primary purpose of generating intermediate code in a compiler?",
    "context": "Intermediate code acts as an abstraction layer to enhance portability and enable easier optimization before final code generation.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "To make optimization and translation easier across platforms",
    "options": [
      "To execute source code",
      "To compress the code size",
      "To directly produce object code",
      "To make optimization and translation easier across platforms"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "Which optimization technique eliminates code that does not affect the program's output?",
    "context": "Dead code elimination removes parts of code that never influence program results, enhancing performance.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Dead Code Elimination",
    "options": [
      "Strength Reduction",
      "Loop Unrolling",
      "Constant Folding",
      "Dead Code Elimination"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "What kind of optimization is 'loop unrolling' categorized as?",
    "context": "Loop unrolling improves performance by reducing loop overhead and increasing parallelism within loops.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Loop Optimization",
    "options": [
      "Peephole Optimization",
      "Constant Propagation",
      "Loop Optimization",
      "Common Subexpression Elimination"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "Which optimization replaces expensive operations with cheaper ones?",
    "context": "Strength reduction replaces costly operations (like multiplication) with more efficient ones (like addition or shifts).",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Strength Reduction",
    "options": [
      "Inline Expansion",
      "Dead Code Elimination",
      "Strength Reduction",
      "Loop Fusion"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Runtime Environment",
    "question": "What data structure is commonly used to manage function calls and returns in the runtime environment?",
    "context": "The call stack keeps track of active subroutines and their local variables during program execution.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Call Stack",
    "options": [
      "Symbol Table",
      "Heap",
      "Call Stack",
      "Activation Record"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Runtime Environment",
    "question": "In a typical runtime environment, what does an activation record store?",
    "context": "An activation record contains necessary information for a function call, including parameters, local variables, and return address.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Local variables, return address, and parameters",
    "options": [
      "Only global variables",
      "Local variables, return address, and parameters",
      "Only return address",
      "Only function name"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Intermediate Code Generation",
    "subtopic": "Three Address Code",
    "question": "Which intermediate representation uses at most three addresses per instruction?",
    "context": "Three Address Code is an intermediate representation where each instruction has at most one operator and three addresses (two operands and one result).",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Three Address Code",
    "options": [
      "Quadruples",
      "Abstract Syntax Tree",
      "Parse Tree",
      "Three Address Code"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Intermediate Code Generation",
    "subtopic": "Syntax Directed Translation",
    "question": "In syntax directed translation, what are semantic actions attached to?",
    "context": "Syntax directed translation attaches semantic actions to grammar production rules to generate intermediate code during parsing.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Grammar production rules",
    "options": [
      "Lexical tokens only",
      "Machine instructions",
      "Symbol table entries",
      "Grammar production rules"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Code Optimization",
    "subtopic": "Loop Optimization",
    "question": "Which optimization technique moves loop-invariant code outside the loop?",
    "context": "Code Motion optimization identifies computations that produce the same result on every iteration and moves them outside the loop to reduce redundant calculations.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Code Motion",
    "options": [
      "Code Motion",
      "Strength Reduction",
      "Dead Code Elimination",
      "Loop Unrolling"
    ]
  },
  {
    "goal": "GATE CSE",
    "subtopic": "Peephole Optimization",
    "question": "What is the primary characteristic of peephole optimization?",
    "context": "Peephole optimization examines a small window (peephole) of instructions and replaces instruction sequences with faster or shorter sequences.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Examines small window of instructions",
    "options": [
      "Examines small window of instructions",
      "Reorganizes data structures",
      "Analyzes entire program flow",
      "Optimizes memory allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Code Optimization",
    "subtopic": "Data Flow Analysis",
    "question": "Which data flow analysis technique is used to eliminate dead code?",
    "context": "Live Variable Analysis determines which variables are live (may be used before being redefined) at each program point, helping identify and eliminate dead code.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Live Variable Analysis",
    "options": [
      "Live Variable Analysis",
      "Available Expressions",
      "Reaching Definitions",
      "Dominance Analysis"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Runtime Environment",
    "subtopic": "Activation Records",
    "question": "What is stored in the activation record of a function call?",
    "context": "Activation records store information needed for function execution including local variables, parameters, return address, and control links.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Local variables and return address",
    "options": [
      "Compiler directives",
      "Global variables only",
      "Local variables and return address",
      "Machine code instructions"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Runtime Environment",
    "subtopic": "Memory Management",
    "question": "Which memory allocation strategy is used for dynamic memory allocation at runtime?",
    "context": "Heap allocation manages dynamic memory allocation at runtime, allowing programs to allocate and deallocate memory blocks of varying sizes during execution.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Heap allocation",
    "options": [
      "Stack allocation",
      "Heap allocation",
      "Static allocation",
      "Register allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Intermediate Code Generation",
    "question": "Which form of intermediate code represents a program as a sequence of three-address instructions?",
    "context": "Three-Address Code is an intermediate representation where each instruction has at most three operands, used to simplify code generation and optimization in compilers.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Three-Address Code",
    "options": [
      "Three-Address Code",
      "Abstract Syntax Tree",
      "Control Flow Graph",
      "Postfix Notation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Intermediate Code Generation",
    "question": "Which intermediate representation is commonly used to capture the hierarchical structure of a program during compilation?",
    "context": "An Abstract Syntax Tree (AST) represents the syntactic structure of source code in a tree form, capturing the hierarchy of operations and facilitating semantic analysis and code generation.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Abstract Syntax Tree",
    "options": [
      "Static Single Assignment",
      "Three-Address Code",
      "Quadruples",
      "Abstract Syntax Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "Which code optimization technique eliminates redundant computations by storing and reusing previously computed values?",
    "context": "Common Subexpression Elimination identifies and removes redundant computations in a program by reusing values already computed, reducing execution time without changing program behavior.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Common Subexpression Elimination",
    "options": [
      "Dead Code Elimination",
      "Constant Folding",
      "Loop Unrolling",
      "Common Subexpression Elimination"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "Which optimization technique evaluates constant expressions at compile time to reduce runtime computation?",
    "context": "Constant Folding evaluates expressions with constant values during compilation, replacing them with their results to reduce runtime overhead, such as replacing 2 + 3 with 5.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Constant Folding",
    "options": [
      "Strength Reduction",
      "Constant Folding",
      "Inline Expansion",
      "Loop Invariant Code Motion"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Runtime Environment",
    "question": "Which data structure is used in the runtime environment to manage function calls and their local variables?",
    "context": "An Activation Record, stored on the runtime stack, contains information like local variables, parameters, and return addresses for each function call, enabling proper function execution and return.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Activation Record",
    "options": [
      "Symbol Table",
      "Activation Record",
      "Parse Tree",
      "Heap"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "Which optimization replaces expensive operations, such as multiplication, with equivalent cheaper operations, like addition, in loops?",
    "context": "Strength Reduction optimizes loops by replacing costly operations (e.g., multiplication) with less expensive ones (e.g., addition), such as replacing i * 2 with i + i, improving performance.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Strength Reduction",
    "options": [
      "Strength Reduction",
      "Loop Fusion",
      "Dead Code Elimination",
      "Constant Propagation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Runtime Environment",
    "question": "Which memory allocation strategy in the runtime environment allows dynamic allocation of objects whose size is determined at runtime?",
    "context": "Heap Allocation manages dynamic memory for objects like arrays or structures whose size is determined at runtime, allowing flexible memory use but requiring explicit deallocation to avoid leaks.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Heap Allocation",
    "options": [
      "Register Allocation",
      "Stack Allocation",
      "Static Allocation",
      "Heap Allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Intermediate Code Generation",
    "question": "After the parsing phase, a compiler typically generates an intermediate representation of the source code. Which form of intermediate code is a common choice that closely resembles machine code and is suitable for subsequent optimization passes, often using 'three-address instructions'?",
    "context": "Three-address code is a popular form of intermediate code where each instruction involves at most three operands (e.g., `x = y op z`). It's a linear, low-level representation that simplifies subsequent code optimization and code generation phases, making it easier to transform into machine-specific instructions.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Three-Address Code",
    "options": [
      "Reverse Polish Notation (RPN)",
      "Abstract Syntax Tree (AST)",
      "Three-Address Code",
      "Directed Acyclic Graph (DAG)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Intermediate Code Generation",
    "question": "During the intermediate code generation phase of a compiler, for an expression like `(a + b) * (c - d)`, which representation explicitly shows the hierarchical structure and common subexpressions, making it suitable for certain optimizations before linear code generation?",
    "context": "A Directed Acyclic Graph (DAG) is a graphical representation of expressions that clearly shows the common subexpressions and the dependencies between operations. It can be constructed from an Abstract Syntax Tree (AST) and is useful for optimizations like common subexpression elimination before generating linear intermediate code like three-address code.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Directed Acyclic Graph (DAG)",
    "options": [
      "Control Flow Graph (CFG)",
      "Postfix Notation",
      "Directed Acyclic Graph (DAG)",
      "Three-Address Code"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "A software team is trying to improve the runtime performance of a critical loop in their application. A simple optimization involves replacing `x = x + 0` or `y = y * 1` with just `x` or `y`. What type of code optimization does this fall under?",
    "context": "Optimizations like `x = x + 0` becoming `x` and `y = y * 1` becoming `y` are forms of algebraic simplification or constant folding/propagation. These are local optimizations that simplify expressions based on mathematical identities, leading to more efficient code.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Constant Folding/Propagation or Algebraic Simplification",
    "options": [
      "Strength Reduction",
      "Loop Invariant Code Motion",
      "Dead Code Elimination",
      "Constant Folding/Propagation or Algebraic Simplification"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "In a loop, an expression `result = A[i] + B[j]` is computed, where `A` and `B` are arrays, and `i` and `j` are loop-invariant (do not change within the loop). What type of loop optimization aims to move such computations outside the loop to reduce redundant calculations?",
    "context": "Loop invariant code motion is an optimization technique that identifies computations whose results do not change within a loop (loop invariants) and moves them outside the loop. This reduces the number of times these computations are performed, thereby improving the overall execution speed of the program.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Loop Invariant Code Motion",
    "options": [
      "Loop Invariant Code Motion",
      "Dead Code Elimination",
      "Peephole Optimization",
      "Register Allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Runtime Environment",
    "question": "When a function is called in a high-level programming language, what data structure is primarily used by the runtime system to manage local variables, parameters, and return addresses for recursive function calls?",
    "context": "The runtime stack is a crucial component of a program's runtime environment, particularly for managing function calls. Each time a function is called, an 'activation record' (also known as a stack frame) is pushed onto the stack. This record contains information pertinent to that function's execution, including local variables, parameters, and the return address, enabling proper function execution and recursion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Activation Record (or Stack Frame) on the runtime stack",
    "options": [
      "Heap",
      "Code Segment",
      "Activation Record (or Stack Frame) on the runtime stack",
      "Static Data Area"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Runtime Environment",
    "question": "What is the primary purpose of the 'heap' memory area in a typical program's runtime environment?",
    "context": "The heap is a dynamic memory allocation area used for data whose size is not known at compile time or whose lifetime is not tied to the scope of a function (e.g., dynamically allocated objects, linked lists, trees). Memory on the heap is explicitly requested by the program (e.g., using `malloc` or `new`) and must be explicitly deallocated to prevent memory leaks.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To allocate memory for data structures whose size is not known at compile time or whose lifetime extends beyond a single function call.",
    "options": [
      "To store executable machine code instructions.",
      "To manage local variables and function call information.",
      "To store global and static variables with a fixed lifetime.",
      "To allocate memory for data structures whose size is not known at compile time or whose lifetime extends beyond a single function call."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Compiler Design",
    "subtopic": "Code Optimization",
    "question": "In a performance-critical application, a compiler might replace a multiplication operation (e.g., `x * 8`) with a series of left bit shifts (e.g., `x << 3`). What optimization technique is this an example of?",
    "context": "Strength reduction is a code optimization technique that replaces computationally 'expensive' operations with equivalent but 'cheaper' operations. For example, replacing multiplication by a power of two with bit shifts or replacing multiplication within a loop with additions, which can be significantly faster on many architectures.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Strength Reduction",
    "options": [
      "Common Subexpression Elimination",
      "Strength Reduction",
      "Dead Code Elimination",
      "Loop Unrolling"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Processes and Threads",
    "question": "Which of the following best differentiates a process from a thread?",
    "context": "A process is an independent unit with its own memory, while threads within a process share the same memory space.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "A process has its own memory space, whereas threads share memory within the process",
    "options": [
      "Threads have their own memory, processes share memory",
      "A process has its own memory space, whereas threads share memory within the process",
      "Threads can run without processes",
      "Processes execute faster than threads"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Processes and Threads",
    "question": "Why are threads considered more efficient than processes?",
    "context": "Threads are lightweight because they share memory and resources of the parent process, making context switching faster and less expensive.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Threads share memory and resources, reducing overhead",
    "options": [
      "Threads share memory and resources, reducing overhead",
      "Threads do not require a CPU",
      "Threads run on different processors",
      "Threads execute only kernel code"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "CPU Scheduling",
    "question": "Which CPU scheduling algorithm may lead to starvation?",
    "context": "SJF can cause starvation for longer processes if shorter ones keep arriving.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Shortest Job First (SJF)",
    "options": [
      "First Come First Serve",
      "Shortest Job First (SJF)",
      "Multilevel Queue",
      "Round Robin"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "CPU Scheduling",
    "question": "In Round Robin scheduling, what determines the responsiveness of a process?",
    "context": "In Round Robin, a small time quantum improves responsiveness but increases context switching overhead.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Time Quantum",
    "options": [
      "Time Quantum",
      "Priority",
      "Process ID",
      "CPU Burst Time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization & Deadlocks",
    "question": "Which condition is necessary for a deadlock to occur?",
    "context": "Deadlock occurs when mutual exclusion, hold and wait, no preemption, and circular wait conditions are present.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Mutual Exclusion",
    "options": [
      "Context Switching",
      "Mutual Exclusion",
      "Interrupts",
      "Scheduling"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization & Deadlocks",
    "question": "What is the purpose of a semaphore in process synchronization?",
    "context": "Semaphores are synchronization tools used to prevent race conditions by controlling access to shared resources.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To control access to shared resources",
    "options": [
      "To control access to shared resources",
      "To schedule threads",
      "To manage memory paging",
      "To allocate CPU time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization & Deadlocks",
    "question": "Which of the following is a deadlock avoidance algorithm?",
    "context": "Banker’s algorithm avoids deadlock by simulating resource allocation and checking for safe states.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Banker's Algorithm",
    "options": [
      "Priority Scheduling",
      "Banker's Algorithm",
      "FCFS Scheduling",
      "Shortest Remaining Time First"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Processes and Threads",
    "question": "Which entity in an operating system represents an independent unit of execution with its own memory space?",
    "context": "A process is an independent unit of execution in an operating system, with its own memory space, program counter, and system resources, unlike threads which share memory within a process.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Process",
    "options": [
      "Thread",
      "Kernel",
      "Process",
      "Interrupt"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Processes and Threads",
    "question": "Which component of a process shares the same address space but has its own stack and registers?",
    "context": "Threads within a process share the same address space and resources but maintain their own stack and registers, enabling lightweight concurrent execution within a single process.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Thread",
    "options": [
      "Monitor",
      "Semaphore",
      "Process",
      "Thread"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "CPU Scheduling",
    "question": "Which CPU scheduling algorithm selects the process with the shortest next CPU burst time to execute next?",
    "context": "Shortest Job Next (SJN), also known as Shortest Job First, selects the process with the shortest predicted CPU burst time, minimizing average waiting time in non-preemptive scheduling.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Shortest Job Next",
    "options": [
      "Shortest Job Next",
      "Round Robin",
      "Priority Scheduling",
      "First-Come-First-Serve"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "CPU Scheduling",
    "question": "Which scheduling algorithm uses a fixed time quantum to preempt processes and cycle through them in a queue?",
    "context": "Round Robin (RR) scheduling allocates a fixed time quantum to each process in a cyclic queue, ensuring fair CPU allocation and responsiveness in time-sharing systems.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Round Robin",
    "options": [
      "Round Robin",
      "Shortest Remaining Time First",
      "Multilevel Queue",
      "Earliest Deadline First"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization",
    "question": "Which synchronization mechanism ensures mutual exclusion by allowing only one process to access a critical section at a time?",
    "context": "A Mutex (Mutual Exclusion) lock ensures that only one process or thread can enter a critical section at a time, preventing race conditions in concurrent programming.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Mutex",
    "options": [
      "Semaphore",
      "Mutex",
      "Monitor",
      "Barrier"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Deadlocks",
    "question": "Which condition must be eliminated to prevent deadlocks in a system with multiple processes competing for resources?",
    "context": "The Circular Wait condition, where processes form a cycle waiting for resources held by others, is one of the four necessary conditions for a deadlock; breaking it prevents deadlocks.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Circular Wait",
    "options": [
      "No Preemption",
      "Hold and Wait",
      "Circular Wait",
      "Mutual Exclusion"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization",
    "question": "Which synchronization technique uses a high-level construct that combines mutual exclusion with condition variables to manage concurrent access to shared resources?",
    "context": "A Monitor is a high-level synchronization construct that encapsulates shared resources, ensuring mutual exclusion and providing condition variables for processes to wait or signal, simplifying concurrent programming.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Monitor",
    "options": [
      "Mutex",
      "Monitor",
      "Semaphore",
      "Spinlock"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Processes and Threads",
    "question": "A web server application needs to handle multiple client requests concurrently to improve responsiveness. Which operating system concept allows for multiple execution flows within the same program, sharing the same memory space, and reducing context switching overhead compared to separate processes?",
    "context": "Threads are lightweight units of execution within a process. Unlike processes, threads within the same process share the same address space, heap, and open files. This shared memory reduces the overhead associated with context switching and inter-thread communication compared to processes, making them ideal for concurrent tasks within a single application like a web server.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Threads",
    "options": [
      "Threads",
      "Virtual Memory",
      "Inter-process Communication (IPC)",
      "Processes"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Processes and Threads",
    "question": "What is the primary difference between a 'process' and a 'thread' in a multi-tasking operating system environment, particularly concerning their resource ownership?",
    "context": "A process is an independent execution unit with its own virtual address space, code, data, and system resources (like open files, signal handlers). Threads, on the other hand, are execution units within a process; they share the process's memory space, open files, and other resources, but each has its own program counter, stack, and register set.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "A process owns its own separate memory space and resources, while threads within a process share the same memory space and resources.",
    "options": [
      "A process owns its own separate memory space and resources, while threads within a process share the same memory space and resources.",
      "Processes can communicate directly, while threads require inter-process communication mechanisms.",
      "Threads are managed by the hardware, while processes are managed by the operating system.",
      "A process executes sequentially, while threads execute concurrently."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "CPU Scheduling",
    "question": "In a batch processing system where turnaround time is the most critical performance metric, and all jobs are known in advance, which CPU scheduling algorithm is theoretically optimal for minimizing average turnaround time?",
    "context": "Shortest-Job-First (SJF) scheduling is provably optimal for minimizing the average waiting time and average turnaround time for a given set of processes, assuming their burst times are known in advance (non-preemptive SJF) or can be accurately predicted (preemptive SJF). This is because it prioritizes shorter jobs, clearing them faster and reducing the overall waiting time for subsequent jobs.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Shortest-Job-First (SJF)",
    "options": [
      "Shortest-Job-First (SJF)",
      "Round Robin",
      "First-Come, First-Served (FCFS)",
      "Priority Scheduling"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "CPU Scheduling",
    "question": "For a real-time operating system managing critical industrial processes, where predictable response times are paramount and tasks have strict deadlines, which CPU scheduling algorithm is most appropriate for guaranteeing that deadlines are met, assuming tasks are periodic and independent?",
    "context": "Rate Monotonic Scheduling (RMS) is a static-priority scheduling algorithm commonly used in real-time operating systems. It assigns higher priorities to tasks with shorter periods (higher rates). RMS is an optimal static-priority algorithm for uniprocessor systems, meaning if a set of tasks can be scheduled by any static-priority algorithm, it can be scheduled by RMS.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Rate Monotonic Scheduling (RMS)",
    "options": [
      "Least Slack Time First (LSTF)",
      "Rate Monotonic Scheduling (RMS)",
      "First-Come, First-Served (FCFS)",
      "Shortest-Remaining-Time-First (SRTF)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization & Deadlocks",
    "question": "Two processes, P1 and P2, need to access a shared resource. To prevent race conditions and ensure data consistency, they use a mutex lock. What is the fundamental principle a mutex enforces to achieve mutual exclusion?",
    "context": "A mutex (mutual exclusion) lock is a synchronization primitive used to protect critical sections of code, ensuring that only one thread or process can access the shared resource at a time. This prevents race conditions and maintains data integrity in concurrent environments.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Only one process can hold the lock and access the critical section at any given time.",
    "options": [
      "Only one process can hold the lock and access the critical section at any given time.",
      "It allows multiple processes to read the shared resource simultaneously.",
      "It allows a process to interrupt another process currently in the critical section.",
      "It ensures processes execute in a strict alternating sequence."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization & Deadlocks",
    "question": "Consider a system with multiple processes and resources where each process needs exclusive access to several resources to complete its task. Which condition, when *not* present, helps prevent deadlocks, and is often addressed by resource ordering or preemption?",
    "context": "Deadlocks occur when four necessary conditions are met simultaneously: Mutual Exclusion, Hold and Wait, No Preemption, and Circular Wait. Breaking any one of these conditions can prevent deadlocks. Circular Wait, where a cycle of processes exists, each holding a resource requested by the next, is often targeted by strategies like resource ordering or breaking the cycle through preemption.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Circular Wait",
    "options": [
      "No Preemption",
      "Hold and Wait",
      "Mutual Exclusion",
      "Circular Wait"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Synchronization & Deadlocks",
    "question": "A classic synchronization problem involves a fixed-size buffer shared between a 'producer' process adding items and a 'consumer' process removing items. What two types of semaphores are typically used to correctly synchronize access to this buffer, ensuring both mutual exclusion and proper counting?",
    "context": "The Producer-Consumer problem requires two types of synchronization. A binary semaphore (or mutex) is used to ensure mutual exclusion, allowing only one process to access the shared buffer at a time. Additionally, two counting semaphores are used: one to count the number of empty slots (initialized to buffer size) and another to count the number of full slots (initialized to 0), ensuring producers wait for empty slots and consumers wait for full slots.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Binary Semaphore (for mutual exclusion) and Counting Semaphores (for empty/full slots)",
    "options": [
      "Only binary semaphores are sufficient.",
      "Mutexes and conditional variables, but not semaphores.",
      "Only counting semaphores are sufficient.",
      "Binary Semaphore (for mutual exclusion) and Counting Semaphores (for empty/full slots)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Processes and Threads",
    "subtopic": "Process Control Block",
    "question": "Which component of Process Control Block (PCB) stores the current execution state of a process?",
    "context": "The Program Counter in PCB maintains the address of the next instruction to be executed, representing the current execution state of the process.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Program Counter",
    "options": [
      "Memory Management Information",
      "Process Priority",
      "Program Counter",
      "Process ID"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Processes and Threads",
    "subtopic": "Thread Types",
    "question": "What is the primary advantage of kernel-level threads over user-level threads?",
    "context": "Kernel-level threads are managed by the OS kernel and can achieve true parallelism on multiprocessor systems since the kernel can schedule different threads on different processors simultaneously.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "True parallelism on multiprocessor systems",
    "options": [
      "No system call overhead",
      "True parallelism on multiprocessor systems",
      "Lower memory overhead",
      "Faster context switching"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "CPU Scheduling",
    "subtopic": "Scheduling Algorithms",
    "question": "In Round Robin scheduling with time quantum 4ms, if processes P1(burst=8ms), P2(burst=3ms), P3(burst=6ms) arrive at t=0, what is the average waiting time?",
    "context": "Round Robin scheduling allocates fixed time quantum to each process in circular order. Average waiting time is calculated by summing individual waiting times and dividing by number of processes.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "7.33ms",
    "options": [
      "6.00ms",
      "5.67ms",
      "8.33ms",
      "7.33ms"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "CPU Scheduling",
    "subtopic": "Priority Scheduling",
    "question": "What problem is commonly associated with non-preemptive priority scheduling?",
    "context": "In priority scheduling, high-priority processes can continuously arrive and execute, causing low-priority processes to wait indefinitely, leading to starvation.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Starvation of low-priority processes",
    "options": [
      "Inefficient CPU utilization",
      "Poor response time for interactive processes",
      "Starvation of low-priority processes",
      "High context switching overhead"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Synchronization & Deadlocks",
    "subtopic": "Peterson's Algorithm",
    "question": "Which two conditions does Peterson's algorithm ensure for critical section problem?",
    "context": "Peterson's algorithm is a software-based solution that guarantees mutual exclusion (only one process in critical section) and progress (processes won't wait indefinitely if critical section is free).",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Mutual exclusion and progress",
    "options": [
      "Mutual exclusion and progress",
      "Mutual exclusion and atomicity",
      "Bounded waiting and atomicity",
      "Progress and consistency"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Synchronization & Deadlocks",
    "subtopic": "Banker's Algorithm",
    "question": "In Banker's algorithm, what does the 'Need' matrix represent?",
    "context": "The Need matrix in Banker's algorithm represents the remaining resource requirement for each process, calculated as Max - Allocation, indicating how many more resources each process needs to complete.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Maximum resource requirement minus current allocation",
    "options": [
      "Current resource allocation to processes",
      "Maximum resource requirement minus current allocation",
      "Maximum resource requirement of processes",
      "Total available resources in the system"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Synchronization & Deadlocks",
    "subtopic": "Deadlock Conditions",
    "question": "Which technique prevents deadlock by ensuring that processes request resources in a predetermined order?",
    "context": "Resource ordering prevents circular wait condition by imposing a total ordering on resource types and requiring processes to request resources in increasing order of enumeration.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Resource ordering",
    "options": [
      "Wound-wait scheme",
      "Resource ordering",
      "Timeout mechanism",
      "Wait-die scheme"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management",
    "question": "What is a key difference between paging and segmentation in memory management?",
    "context": "Paging splits memory into equal-sized pages while segmentation uses variable-sized segments based on logical divisions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Paging divides memory into fixed-size blocks, segmentation uses variable-size segments",
    "options": [
      "Paging uses variable-size blocks, segmentation uses fixed-size blocks",
      "Segmentation and paging are identical methods",
      "Paging divides memory into fixed-size blocks, segmentation uses variable-size segments",
      "Both use fixed-size memory divisions"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management",
    "question": "Why does paging eliminate external fragmentation?",
    "context": "Paging eliminates external fragmentation by allocating fixed-size pages in memory.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Because physical memory is allocated in fixed-size blocks",
    "options": [
      "Because memory is dynamically compressed during execution",
      "Because physical memory is allocated in fixed-size blocks",
      "Because logical memory is divided into segments",
      "Because memory is allocated to only one process at a time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "File Systems",
    "question": "Which of the following allocation methods can cause external fragmentation in file systems?",
    "context": "Contiguous allocation places a file in a single stretch of memory, which may lead to external fragmentation as files are deleted and created.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Contiguous allocation",
    "options": [
      "Linked allocation",
      "Contiguous allocation",
      "Indexed allocation",
      "Hashed allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "File Systems",
    "question": "Which file allocation method allows fast direct access and easy block retrieval?",
    "context": "Indexed allocation maintains an index block for each file, enabling fast access to any block without traversing.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Indexed allocation",
    "options": [
      "Indexed allocation",
      "Dynamic partitioning",
      "Contiguous allocation",
      "Linked allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "I/O and Disk Scheduling",
    "question": "Which disk scheduling algorithm provides the best average response time but may lead to starvation?",
    "context": "SSTF selects the request with the least seek time, improving performance but may indefinitely postpone distant requests.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Shortest Seek Time First (SSTF)",
    "options": [
      "SCAN",
      "FCFS (First Come First Serve)",
      "Shortest Seek Time First (SSTF)",
      "C-SCAN"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "I/O and Disk Scheduling",
    "question": "What is the primary advantage of the SCAN disk scheduling algorithm?",
    "context": "SCAN moves the disk arm across the disk, servicing requests in one direction to reduce wait times without starvation.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "It provides better response time than FCFS and avoids starvation",
    "options": [
      "It always chooses the farthest cylinder",
      "It is faster than SSTF in all cases",
      "It provides better response time than FCFS and avoids starvation",
      "It skips alternating tracks for efficiency"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management",
    "question": "Which of the following is true about page replacement algorithms in virtual memory systems?",
    "context": "Page replacement algorithms decide which page to remove when memory is full; LRU is based on past usage patterns.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "The Least Recently Used (LRU) algorithm replaces the page not used for the longest time",
    "options": [
      "The Least Recently Used (LRU) algorithm replaces the page not used for the longest time",
      "FIFO replaces the page with the highest priority",
      "LRU always replaces the largest page in memory",
      "Optimal replaces the page that was most recently accessed"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Memory Management",
    "subtopic": "Paging",
    "question": "In a paging system with page size 4KB and virtual address space 32 bits, how many bits are required for the page offset?",
    "context": "Page offset bits are determined by page size. With 4KB (4096 bytes) page size, we need log₂(4096) = 12 bits to address all bytes within a page.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "12 bits",
    "options": [
      "12 bits",
      "16 bits",
      "10 bits",
      "8 bits"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Memory Management",
    "subtopic": "Segmentation",
    "question": "What is the primary advantage of segmentation over paging in terms of memory organization?",
    "context": "Segmentation allows logical grouping of program components like code, data, and stack segments, making it easier to share and protect related memory regions compared to fixed-size pages.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Logical grouping of related data and code",
    "options": [
      "Reduced memory overhead",
      "Faster address translation",
      "Logical grouping of related data and code",
      "Elimination of external fragmentation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Memory Management",
    "subtopic": "Page Replacement",
    "question": "In LRU page replacement algorithm, if page reference string is 1,2,3,4,1,2,5,1,2,3,4,5 with 3 frames, how many page faults occur?",
    "context": "LRU (Least Recently Used) replaces the page that has not been referenced for the longest time. Each new page reference that's not in memory causes a page fault.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "9",
    "options": [
      "10",
      "7",
      "9",
      "8"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "File Systems",
    "subtopic": "File Allocation Methods",
    "question": "Which file allocation method provides the best sequential access performance?",
    "context": "Contiguous allocation stores file blocks in consecutive disk locations, allowing the disk head to read sequential blocks without seeking, providing optimal sequential access performance.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Contiguous allocation",
    "options": [
      "Multi-level indexed allocation",
      "Linked allocation",
      "Contiguous allocation",
      "Indexed allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "File Systems",
    "subtopic": "Directory Structure",
    "question": "What is the main disadvantage of single-level directory structure?",
    "context": "Single-level directory structure maintains all files in one directory, causing naming conflicts when multiple users try to create files with the same name.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Name collision between different users",
    "options": [
      "High memory overhead for directory table",
      "Name collision between different users",
      "Complex file path resolution",
      "Inefficient file search operations"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "I/O and Disk Scheduling",
    "subtopic": "SCAN Algorithm",
    "question": "In SCAN disk scheduling, if current head position is 53 and requests are [98, 183, 37, 122, 14, 124, 65, 67], what is the total head movement assuming head moves towards higher cylinder numbers?",
    "context": "SCAN algorithm moves the disk head in one direction servicing requests until reaching the end, then reverses direction. Total movement is calculated by summing all head movements between consecutive positions.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "236",
    "options": [
      "236",
      "198",
      "208",
      "256"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "I/O and Disk Scheduling",
    "subtopic": "DMA vs Programmed I/O",
    "question": "What is the primary advantage of DMA (Direct Memory Access) over programmed I/O?",
    "context": "DMA allows I/O devices to transfer data directly to/from memory without CPU intervention, freeing the CPU to execute other processes while data transfer occurs in parallel.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "CPU is free to perform other tasks during data transfer",
    "options": [
      "Lower hardware complexity",
      "Better error detection capabilities",
      "CPU is free to perform other tasks during data transfer",
      "Higher data transfer rate"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management",
    "question": "Which memory management technique divides physical memory into fixed-size blocks called pages?",
    "context": "Paging divides physical memory into fixed-size pages and maps them to logical pages, allowing efficient memory allocation and avoiding external fragmentation in operating systems.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Paging",
    "options": [
      "Segmentation",
      "Thrashing",
      "Virtual Memory",
      "Paging"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management",
    "question": "Which memory management technique allows variable-sized memory partitions based on program segments like code or data?",
    "context": "Segmentation divides a program into variable-sized segments (e.g., code, data, stack), each mapped to memory, supporting logical partitioning but potentially causing external fragmentation.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Segmentation",
    "options": [
      "Swapping",
      "Paging",
      "Demand Paging",
      "Segmentation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "File Systems",
    "question": "Which file system component stores metadata about files, such as their names, sizes, and locations?",
    "context": "An inode in a file system stores metadata about a file, including its size, permissions, and pointers to data blocks, enabling efficient file access and management.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Inode",
    "options": [
      "Inode",
      "Directory",
      "Superblock",
      "Boot Block"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "File Systems",
    "question": "Which file allocation method uses a linked list to track the blocks of a file on disk?",
    "context": "Linked Allocation stores a file as a linked list of disk blocks, where each block contains a pointer to the next, allowing flexibility but potentially slower sequential access.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Linked Allocation",
    "options": [
      "Extent-based Allocation",
      "Linked Allocation",
      "Indexed Allocation",
      "Contiguous Allocation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "I/O and Disk Scheduling",
    "question": "Which disk scheduling algorithm selects the request with the shortest seek time from the current head position?",
    "context": "Shortest Seek Time First (SSTF) selects the disk I/O request closest to the current head position, minimizing seek time but potentially causing starvation for distant requests.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Shortest Seek Time First",
    "options": [
      "SCAN",
      "First-Come-First-Serve",
      "C-SCAN",
      "Shortest Seek Time First"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management",
    "question": "Which page replacement algorithm replaces the page that will not be needed for the longest time in the future?",
    "context": "Optimal Page Replacement selects the page that will not be referenced for the longest time, minimizing page faults, but it requires future knowledge and is impractical in real systems.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Optimal Page Replacement",
    "options": [
      "Optimal Page Replacement",
      "Most Recently Used",
      "Least Recently Used",
      "First-In-First-Out"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "I/O and Disk Scheduling",
    "question": "Which disk scheduling algorithm moves the disk head in one direction, servicing requests until it reaches the end, then reverses direction?",
    "context": "The SCAN algorithm, also known as the elevator algorithm, services disk requests in one direction until the end of the disk, then reverses, ensuring fairness but potentially higher seek times than LOOK.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "SCAN",
    "options": [
      "C-SCAN",
      "SCAN",
      "Shortest Seek Time First",
      "LOOK"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management (Paging, Segmentation)",
    "question": "A modern operating system needs to manage processes with varying memory requirements, allowing them to run even if their entire logical address space cannot fit contiguously in physical memory. Which memory management technique achieves this by dividing both logical and physical memory into fixed-size blocks?",
    "context": "Paging is a memory management scheme that divides logical memory into fixed-size blocks called pages and physical memory into fixed-size blocks called frames. This allows a process's non-contiguous logical pages to be stored in non-contiguous physical frames, solving the external fragmentation problem and enabling virtual memory.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Paging",
    "options": [
      "Contiguous Memory Allocation",
      "Segmentation",
      "Swapping",
      "Paging"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management (Paging, Segmentation)",
    "question": "In a system using a two-level paging scheme, what is the primary benefit over a single-level paging scheme, especially for processes with sparse address spaces?",
    "context": "Multi-level paging (like two-level paging) addresses the issue of large page tables consuming too much memory, especially for processes that use only a small portion of their large logical address space (sparse address space). It achieves this by only allocating inner page tables for those parts of the logical address space that are actually in use, thus saving significant memory.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Reduced memory usage for page tables by not requiring a full page table for every process.",
    "options": [
      "Faster page table lookups.",
      "Reduced memory usage for page tables by not requiring a full page table for every process.",
      "Elimination of internal fragmentation.",
      "Support for sharing code segments between processes."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "Memory Management (Paging, Segmentation)",
    "question": "A legacy operating system uses segmentation for memory management. What is a key advantage of segmentation over pure paging from a programmer's perspective, related to program structure?",
    "context": "Segmentation is a memory management scheme where memory is divided into segments of varying sizes, each corresponding to a logical unit of a program (e.g., code segment, data segment, stack segment). This aligns well with how programmers typically organize their programs, offering better protection and sharing at a logical level compared to fixed-size pages.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "It reflects the logical organization of a program (e.g., code, data, stack) into variable-sized segments.",
    "options": [
      "It always uses less total physical memory than paging.",
      "It provides faster physical address translation than paging.",
      "It completely eliminates internal fragmentation.",
      "It reflects the logical organization of a program (e.g., code, data, stack) into variable-sized segments."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "File Systems",
    "question": "A user deletes a large file from a disk. In a typical file system, what is the immediate action taken by the operating system, and how does this relate to the actual data on the disk?",
    "context": "When a file is deleted in most modern file systems, the operating system doesn't immediately erase the data blocks containing the file's content. Instead, it marks the directory entry as invalid and updates the file system's free space map (e.g., bitmap or free list) to indicate that the blocks previously occupied by the file are now available for reuse. The actual data remains on the disk until new data overwrites those blocks.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "The file's entry in the directory is marked as free, and its disk blocks are marked as available, but the data itself remains until overwritten.",
    "options": [
      "The file is moved to a special 'recycle bin' area on the disk.",
      "The entire file's data is immediately overwritten with zeros for security.",
      "The disk controller automatically erases the magnetic patterns of the data blocks.",
      "The file's entry in the directory is marked as free, and its disk blocks are marked as available, but the data itself remains until overwritten."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "File Systems",
    "question": "In a distributed file system, which common challenge arises when multiple clients try to modify the same file concurrently, and how is it typically addressed?",
    "context": "Consistency is a major challenge in distributed file systems. When multiple clients can access and modify the same file concurrently, ensuring that all clients see a consistent (up-to-date) view of the file becomes complex. This is typically addressed using various consistency models, often implemented through locking mechanisms (e.g., pessimistic locking) or optimistic concurrency control with versioning.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Consistency, often handled through locking mechanisms or versioning.",
    "options": [
      "Consistency, often handled through locking mechanisms or versioning.",
      "Performance, by increasing network bandwidth.",
      "Security, by encrypting all file transfers.",
      "Storage capacity, by adding more disk space."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "I/O and Disk Scheduling",
    "question": "A hard disk drive is receiving multiple I/O requests for data blocks located at various cylinder numbers. Which disk scheduling algorithm aims to minimize the total head movement by always moving the disk arm in one direction until it reaches an end, then reverses direction?",
    "context": "The SCAN disk scheduling algorithm, also known as the elevator algorithm, operates by moving the disk arm in one direction, servicing all requests along the way, until it reaches the end of the disk or the last request in that direction. It then reverses direction and repeats the process. This helps minimize total head movement and provides a more fair service compared to SSTF, which can starve requests at the ends.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "SCAN (Elevator Algorithm)",
    "options": [
      "C-SCAN (Circular SCAN)",
      "SSTF (Shortest-Seek-Time-First)",
      "FCFS (First-Come, First-Served)",
      "SCAN (Elevator Algorithm)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Operating Systems",
    "subtopic": "I/O and Disk Scheduling",
    "question": "Why is the use of a disk cache (buffer cache) crucial for improving the performance of file system operations in an operating system?",
    "context": "A disk cache (or buffer cache) is a portion of main memory (RAM) used by the operating system to store frequently accessed disk blocks. The primary benefit is to reduce the need for slow physical disk I/O operations. When data is requested, the system first checks the cache; if found (a cache hit), it's served much faster than reading from the disk, significantly improving performance.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "It reduces the number of slow physical disk I/O operations by serving frequently accessed data from faster memory.",
    "options": [
      "It encrypts data before writing to the disk for enhanced security.",
      "It reduces the number of slow physical disk I/O operations by serving frequently accessed data from faster memory.",
      "It automatically defragments the disk in real-time.",
      "It organizes files into a hierarchical structure on the disk."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "ER Model and Relational Model",
    "question": "In the ER model, what does a weak entity set lack that requires it to be associated with a strong entity?",
    "context": "A weak entity set cannot be uniquely identified by its own attributes and needs a foreign key from a strong entity to create a primary key.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "A primary key",
    "options": [
      "A primary key",
      "A foreign key",
      "An attribute",
      "A relation name"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Relational Algebra and SQL",
    "question": "Which relational algebra operation is used to combine tuples from two relations based on a common attribute?",
    "context": "The join operation combines tuples from two relations based on matching attribute values.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Join",
    "options": [
      "Union",
      "Projection",
      "Selection",
      "Join"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Relational Algebra and SQL",
    "question": "What is the main purpose of the 'GROUP BY' clause in SQL?",
    "context": "The 'GROUP BY' clause is used to arrange identical data into groups to perform aggregate functions like COUNT, AVG, SUM, etc.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "To aggregate data based on one or more columns",
    "options": [
      "To aggregate data based on one or more columns",
      "To join two tables",
      "To filter rows before aggregation",
      "To sort the result set"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Relational Algebra and SQL",
    "question": "Which of the following SQL operations eliminates duplicate rows in the result set?",
    "context": "SELECT DISTINCT is used to return only distinct (different) values, removing duplicate rows from the result set.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "SELECT DISTINCT",
    "options": [
      "ORDER BY",
      "SELECT ALL",
      "SELECT DISTINCT",
      "GROUP BY"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Functional Dependencies and Normalization",
    "question": "Which normal form ensures there are no partial dependencies in a relation?",
    "context": "2NF eliminates partial dependency, where a non-prime attribute is functionally dependent on part of a candidate key.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Second Normal Form (2NF)",
    "options": [
      "Third Normal Form (3NF)",
      "Second Normal Form (2NF)",
      "Boyce-Codd Normal Form (BCNF)",
      "First Normal Form (1NF)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Functional Dependencies and Normalization",
    "question": "What is a functional dependency in relational databases?",
    "context": "A functional dependency X → Y means that if two tuples have the same value for attribute X, they must have the same value for attribute Y.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "A relationship where one attribute uniquely determines another attribute",
    "options": [
      "A join between two foreign keys",
      "A mapping of keys to relations",
      "A relationship where one attribute uniquely determines another attribute",
      "A recursive relationship between two attributes"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Functional Dependencies and Normalization",
    "question": "Why is Boyce-Codd Normal Form (BCNF) considered stronger than 3NF?",
    "context": "BCNF is stricter than 3NF as it requires every functional dependency to have a super key on the left-hand side.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Because it removes all anomalies caused by functional dependencies, even if candidate keys are involved",
    "options": [
      "Because it ensures data is stored in one table",
      "Because it merges all relations into a single one",
      "Because it ignores all transitive dependencies",
      "Because it removes all anomalies caused by functional dependencies, even if candidate keys are involved"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "ER Model and Relational Model",
    "subtopic": "Entity-Relationship Mapping",
    "question": "In ER-to-relational mapping, how is a many-to-many relationship between entities A and B typically represented?",
    "context": "Many-to-many relationships cannot be directly represented in relational model and require a separate junction table containing foreign keys from both participating entities to establish the relationship.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Create a separate relation with foreign keys from both A and B",
    "options": [
      "Add foreign key of B in relation A",
      "Add foreign key of A in relation B",
      "Create a separate relation with foreign keys from both A and B",
      "Merge both entities into a single relation"
    ]
  },
  {
    "goal": "GATE CSE",
    "subtopic": "Weak Entity Sets",
    "topic": "ER Model and Relational Model",
    "question": "What additional component is required when converting a weak entity set to a relational schema?",
    "context": "Weak entities depend on owner entities for identification and require the owner entity's primary key as a foreign key, combined with the weak entity's partial key to form the complete primary key.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Primary key of the owner entity as foreign key",
    "options": [
      "Primary key of the owner entity as foreign key",
      "Composite primary key from all attributes",
      "Surrogate key generation",
      "Partial key duplication"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Relational Algebra and SQL",
    "subtopic": "Relational Algebra Operations",
    "question": "Which relational algebra operation is equivalent to the SQL WHERE clause?",
    "context": "Selection operation (σ) in relational algebra filters tuples based on specified conditions, which directly corresponds to the WHERE clause functionality in SQL queries.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Selection (σ)",
    "options": [
      "Join (⋈)",
      "Selection (σ)",
      "Projection (π)",
      "Union (∪)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Relational Algebra and SQL",
    "subtopic": "SQL Joins",
    "question": "What is the result when performing a LEFT OUTER JOIN between tables A(5 tuples) and B(3 tuples) where only 2 tuples from A have matching values in B?",
    "context": "LEFT OUTER JOIN returns all tuples from the left table and matched tuples from the right table, with NULL values for unmatched left table tuples, ensuring all left table records are preserved.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "5 tuples with NULLs for unmatched A tuples",
    "options": [
      "2 tuples with only matched records",
      "5 tuples with NULLs for unmatched A tuples",
      "3 tuples with NULLs for unmatched B tuples",
      "8 tuples from cartesian product"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Functional Dependencies and Normalization",
    "subtopic": "Functional Dependencies",
    "question": "Given relation R(A,B,C,D) with FDs: A→B, B→C, C→D, A→D. Which functional dependency is redundant?",
    "context": "A functional dependency is redundant if it can be derived from other dependencies through transitivity. Since A→B, B→C, C→D exists, A→D can be derived transitively, making it redundant.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "A→D",
    "options": [
      "B→C",
      "A→B",
      "C→D",
      "A→D"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Functional Dependencies and Normalization",
    "subtopic": "Second Normal Form",
    "question": "What condition must be satisfied for a relation to be in Second Normal Form (2NF)?",
    "context": "Second Normal Form requires that the relation is in 1NF and every non-prime attribute is fully functionally dependent on every candidate key, eliminating partial dependencies.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "No partial dependency of non-prime attributes on candidate key",
    "options": [
      "No transitive dependency exists",
      "No partial dependency of non-prime attributes on candidate key",
      "No multi-valued dependencies exist",
      "All attributes are atomic"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Functional Dependencies and Normalization",
    "subtopic": "BCNF Decomposition",
    "question": "A relation R(A,B,C,D) with FDs: AB→C, C→D, D→A is decomposed into R1(A,B,C) and R2(C,D,A). What property does this decomposition satisfy?",
    "context": "The decomposition is lossless because the common attribute C is a key in one of the decomposed relations R2, ensuring that the original relation can be reconstructed by joining R1 and R2.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Lossless join decomposition",
    "options": [
      "Neither lossless nor dependency preserving",
      "Both lossless and dependency preserving",
      "Lossless join decomposition",
      "Dependency preserving decomposition"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "ER Model",
    "question": "Which component of an ER Model represents a real-world object with attributes?",
    "context": "In the ER Model, an entity represents a real-world object (e.g., a student or car) with attributes describing its properties, forming the basis for tables in a relational database.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Entity",
    "options": [
      "Schema",
      "Entity",
      "Relationship",
      "Attribute"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Relational Model",
    "question": "Which property of a relational database ensures that each attribute in a tuple contains exactly one value?",
    "context": "Atomicity in the relational model ensures that each attribute in a tuple holds a single, indivisible value, adhering to the principles of the relational database model.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Atomicity",
    "options": [
      "Consistency",
      "Atomicity",
      "Integrity",
      "Durability"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Relational Algebra",
    "question": "Which relational algebra operation selects tuples from a relation that satisfy a given condition?",
    "context": "The Selection operation in relational algebra filters tuples from a relation based on a specified condition, producing a subset of tuples that satisfy the predicate.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Selection",
    "options": [
      "Union",
      "Join",
      "Selection",
      "Projection"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "SQL",
    "question": "Which SQL clause is used to group rows with identical values in specified columns into summary rows?",
    "context": "The GROUP BY clause in SQL groups rows with the same values in specified columns, often used with aggregate functions like COUNT or SUM to produce summary results.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "GROUP BY",
    "options": [
      "ORDER BY",
      "HAVING",
      "WHERE",
      "GROUP BY"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Functional Dependencies",
    "question": "Which type of functional dependency holds for all instances of a relation if one attribute uniquely determines another?",
    "context": "A Full Functional Dependency exists when an attribute X uniquely determines another attribute Y, and no proper subset of X can determine Y, ensuring minimal dependency.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Full Functional Dependency",
    "options": [
      "Partial Dependency",
      "Multivalued Dependency",
      "Full Functional Dependency",
      "Transitive Dependency"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Normalization",
    "question": "Which normal form eliminates transitive dependencies to ensure that non-key attributes depend only on the primary key?",
    "context": "Third Normal Form (3NF) ensures that all non-key attributes are non-transitively dependent on the primary key, eliminating transitive dependencies to reduce redundancy.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Third Normal Form",
    "options": [
      "Third Normal Form",
      "Second Normal Form",
      "First Normal Form",
      "BCNF"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Normalization",
    "question": "Which normal form is stricter than 3NF and requires that every determinant of a functional dependency be a candidate key?",
    "context": "Boyce-Codd Normal Form (BCNF) is a stricter version of 3NF, requiring that for every functional dependency X → Y, X must be a candidate key, eliminating certain anomalies in updates.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Boyce-Codd Normal Form",
    "options": [
      "Second Normal Form",
      "Fifth Normal Form",
      "Boyce-Codd Normal Form",
      "Fourth Normal Form"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "ER Model and Relational Model",
    "question": "A software development team is designing a new database for a university. They have identified 'Student' and 'Course' as entities, and a 'RegistersFor' relationship where a student can register for multiple courses, and a course can have multiple students. In an ER diagram, how would this relationship be typically represented, and what cardinalities would apply?",
    "context": "A Many-to-Many (M:N) relationship exists when one entity instance can be associated with multiple instances of another entity, and vice versa. In the university example, one student can register for many courses, and one course can have many students. This is typically represented by a diamond connecting the two entity rectangles, with 'M' and 'N' (or '*' for many) cardinalities indicated on the connecting lines.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Many-to-Many (M:N) relationship with a connecting diamond.",
    "options": [
      "A weak entity set dependent on both Student and Course.",
      "Many-to-Many (M:N) relationship with a connecting diamond.",
      "One-to-One (1:1) relationship between Student and Course.",
      "One-to-Many (1:N) relationship from Student to Course."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "ER Model and Relational Model",
    "question": "When converting an ER model with a multi-valued attribute (e.g., 'Phone Numbers' for a 'Customer' entity) into a relational schema, what is the standard approach to represent this attribute?",
    "context": "Multi-valued attributes in an ER model cannot be directly represented as a single column in a relational table without violating First Normal Form (1NF). The standard conversion approach is to create a new, separate relation. This new relation will have two columns: one for the primary key of the original entity (acting as a foreign key) and one for the multi-valued attribute itself. The combination of these two columns forms the primary key of the new relation.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Create a new separate relation (table) for the multi-valued attribute, with a foreign key back to the original entity's primary key.",
    "options": [
      "Simply ignore the multi-valued attribute during conversion as it cannot be directly mapped.",
      "Create a new separate relation (table) for the multi-valued attribute, with a foreign key back to the original entity's primary key.",
      "Create multiple columns in the original relation, one for each possible phone number.",
      "Store all phone numbers as a comma-separated string in a single column of the original relation."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Relational Algebra and SQL",
    "question": "Given two relations, `EMPLOYEE(EmpID, Name, DeptID)` and `DEPARTMENT(DeptID, DeptName, Location)`. Which Relational Algebra operation would be used to find the names of all employees who work in the 'Sales' department?",
    "context": "To find employees in a specific department, you first need to filter the `DEPARTMENT` relation to find the 'Sales' department's `DeptID` (Selection). Then, you join this result with the `EMPLOYEE` relation on `DeptID` to link employees to departments (Join). Finally, you project the `Name` attribute from the result (Projection).",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Selection (σ) on DEPARTMENT, followed by Join (⋈) with EMPLOYEE, then Projection (π) for Name.",
    "options": [
      "Union (∪) of EMPLOYEE and DEPARTMENT.",
      "Division (÷) of EMPLOYEE by DEPARTMENT.",
      "Selection (σ) on DEPARTMENT, followed by Join (⋈) with EMPLOYEE, then Projection (π) for Name.",
      "Cartesian Product (×) of EMPLOYEE and DEPARTMENT, followed by Selection."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Relational Algebra and SQL",
    "question": "You need to retrieve the `EmpID` and `Name` of all employees from the `EMPLOYEE` table where `DeptID` is 'D001' AND `Salary` is greater than 50000. Write the equivalent SQL query.",
    "context": "The `SELECT` clause specifies the columns to retrieve. The `FROM` clause indicates the table. The `WHERE` clause filters rows based on conditions. The `AND` operator combines multiple conditions, requiring both to be true for a row to be selected.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "SELECT EmpID, Name FROM EMPLOYEE WHERE DeptID = 'D001' AND Salary > 50000;",
    "options": [
      "SELECT EmpID, Name FROM EMPLOYEE WHERE DeptID = 'D001' OR Salary > 50000;",
      "SELECT EmpID, Name FROM EMPLOYEE WHERE DeptID = 'D001' AND Salary > 50000;",
      "SELECT EmpID, Name FROM EMPLOYEE GROUP BY DeptID HAVING DeptID = 'D001';",
      "SELECT * FROM EMPLOYEE WHERE DeptID = 'D001' AND Salary > 50000;"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Functional Dependencies and Normalization",
    "question": "A relation `R(A, B, C, D)` has the following functional dependencies: `A → B`, `B → C`, `C → D`. What is the highest normal form that `R` satisfies, and why?",
    "context": "Given `A → B`, `B → C`, and `C → D`, if `A` is a candidate key, then `A → C` (via `A → B` and `B → C`) and `A → D` (via `A → C` and `C → D`) are transitive dependencies. A relation is in 3NF if it's in 2NF and there are no transitive dependencies of non-prime attributes on a candidate key. Since we have transitive dependencies (e.g., `A → C` and `A → D`), the relation is not in 3NF. It is in 1NF as long as all attributes are atomic.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "1NF (First Normal Form), because it might contain transitive dependencies if A is a candidate key.",
    "options": [
      "2NF (Second Normal Form), because B is fully dependent on A.",
      "1NF (First Normal Form), because it might contain transitive dependencies if A is a candidate key.",
      "3NF (Third Normal Form), because there are no partial dependencies.",
      "BCNF (Boyce-Codd Normal Form), because all determinants are candidate keys."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Functional Dependencies and Normalization",
    "question": "What is the primary objective of normalizing a relational database schema to higher normal forms (e.g., 3NF or BCNF)?",
    "context": "Normalization is a systematic process of reorganizing a database to minimize data redundancy and improve data integrity. Its main goals are to eliminate update anomalies (where changing one piece of data requires changing multiple records), insertion anomalies (where data cannot be added without other data), and deletion anomalies (where deleting data inadvertently removes other data).",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To reduce data redundancy and eliminate update, insertion, and deletion anomalies.",
    "options": [
      "To simplify the ER diagram design process.",
      "To improve query execution speed for all types of queries.",
      "To reduce data redundancy and eliminate update, insertion, and deletion anomalies.",
      "To increase the complexity of joining multiple tables."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Functional Dependencies and Normalization",
    "question": "Consider a relation `R(A, B, C, D)` with functional dependencies `AB → C` and `C → D`. Is this relation in Boyce-Codd Normal Form (BCNF)? If not, why?",
    "context": "A relation is in BCNF if and only if for every non-trivial functional dependency `X → Y`, `X` is a superkey (or candidate key). In the given example, `C → D` is a non-trivial functional dependency, but `C` is not a candidate key (the candidate key is `AB`). Therefore, the relation is not in BCNF.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "No, because C is a determinant (C → D) but not a candidate key.",
    "options": [
      "Yes, because it is already in 3NF.",
      "No, because C is a determinant (C → D) but not a candidate key.",
      "Yes, because all functional dependencies are fully dependent on a candidate key.",
      "No, because there is a partial dependency of D on AB."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Transactions and Concurrency Control",
    "question": "Which property ensures that a transaction's changes are permanently recorded in the database even in the case of a system crash?",
    "context": "Durability in database transactions ensures that once a transaction has been committed, its changes are permanent even after a crash.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Durability",
    "options": [
      "Durability",
      "Atomicity",
      "Consistency",
      "Isolation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Transactions and Concurrency Control",
    "question": "Which concurrency control protocol ensures serializability using timestamps?",
    "context": "The timestamp ordering protocol uses timestamps to ensure that the schedule of concurrent transactions is serializable.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Timestamp ordering protocol",
    "options": [
      "Timestamp ordering protocol",
      "Wait-die scheme",
      "Two-phase locking protocol",
      "Validation-based protocol"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Transactions and Concurrency Control",
    "question": "What is the main goal of concurrency control in a DBMS?",
    "context": "Concurrency control ensures correct execution of concurrent transactions while maintaining database consistency and isolation.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To ensure isolation and consistency of transactions",
    "options": [
      "To ensure isolation and consistency of transactions",
      "To increase replication",
      "To enhance disk performance",
      "To perform indexing efficiently"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Indexing and File Organization",
    "question": "Which data structure is commonly used to implement database indexing for efficient range queries?",
    "context": "B+ Trees are widely used in databases for indexing because they support efficient range queries and dynamic insertion/deletion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "B+ Tree",
    "options": [
      "Binary Search Tree",
      "B+ Tree",
      "Hash Table",
      "Red-Black Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Indexing and File Organization",
    "question": "Which of the following is a primary advantage of clustered indexing?",
    "context": "Clustered indexing improves performance by storing related rows together, reducing disk I/O during access.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "It stores related rows physically close on disk, improving I/O",
    "options": [
      "It stores related rows physically close on disk, improving I/O",
      "It enforces referential integrity",
      "It disables secondary indexing",
      "It duplicates rows across tables"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Databases",
    "subtopic": "Indexing and File Organization",
    "question": "Which type of file organization allows fast sequential access and also supports indexed access?",
    "context": "ISAM combines both sequential and indexed access, providing efficient retrieval and update operations in databases.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Indexed Sequential Access Method (ISAM)",
    "options": [
      "Hashed File Organization",
      "Clustered File Organization",
      "Indexed Sequential Access Method (ISAM)",
      "Heap File Organization"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Transactions, Concurrency Control",
    "subtopic": "ACID Properties",
    "question": "Which ACID property ensures that either all operations of a transaction are completed or none are performed?",
    "context": "Atomicity property ensures that a transaction is treated as a single unit of work where either all operations are executed successfully or none are executed, maintaining an all-or-nothing approach.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Atomicity",
    "options": [
      "Consistency",
      "Durability",
      "Atomicity",
      "Isolation"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Transactions, Concurrency Control",
    "subtopic": "Two-Phase Locking",
    "question": "In Two-Phase Locking protocol, what happens during the shrinking phase?",
    "context": "Two-Phase Locking has a growing phase where locks are acquired and a shrinking phase where locks are released. Once a transaction enters the shrinking phase, it cannot acquire any new locks.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Locks can only be released, no new locks can be acquired",
    "options": [
      "Both lock acquisition and release are allowed",
      "Locks can only be released, no new locks can be acquired",
      "Locks can only be acquired, no locks can be released",
      "All locks are automatically released"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Transactions, Concurrency Control",
    "subtopic": "Serializability",
    "question": "What type of schedule is guaranteed to be conflict-serializable?",
    "context": "Two-Phase Locking protocol guarantees conflict-serializability by ensuring that all transactions follow the growing and shrinking phases, preventing conflicting operations from executing concurrently.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Any schedule that follows Two-Phase Locking protocol",
    "options": [
      "Any schedule that follows Two-Phase Locking protocol",
      "Any schedule with optimistic concurrency control",
      "Any schedule without deadlocks",
      "Any schedule with timestamp ordering"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Indexing and File Organization",
    "subtopic": "B+ Tree Structure",
    "question": "What is the maximum number of keys that can be stored in a B+ tree node with order 4?",
    "context": "In a B+ tree of order n, each internal node can contain at most (n-1) keys and n pointers. For order 4, maximum keys per node is 4-1 = 3 keys.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "3",
    "options": [
      "2",
      "4",
      "5",
      "3"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Indexing and File Organization",
    "subtopic": "Hashing vs B+ Tree",
    "question": "Which indexing method provides better performance for range queries?",
    "context": "B+ Tree maintains sorted order of keys and supports sequential access through leaf node links, making it efficient for range queries, while hashing provides direct access but poor range query performance.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "B+ Tree",
    "options": [
      "Extensible Hashing",
      "Static Hashing",
      "Dynamic Hashing",
      "B+ Tree"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Indexing and File Organization",
    "subtopic": "Clustered vs Non-clustered Index",
    "question": "What is the primary characteristic of a clustered index?",
    "context": "A clustered index physically orders the data records in the table according to the index key values, meaning the data pages are stored in the same order as the index key sequence.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Data records are physically ordered according to the index key",
    "options": [
      "Multiple clustered indexes can exist per table",
      "Data records are physically ordered according to the index key",
      "Index is stored separately from data pages",
      "Index entries point to data record locations"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Transactions",
    "question": "Which property of a transaction ensures that all operations are completed successfully or none are applied?",
    "context": "Atomicity ensures that a transaction is treated as an indivisible unit, either fully completing or rolling back entirely, maintaining database integrity.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Atomicity",
    "options": [
      "Consistency",
      "Isolation",
      "Atomicity",
      "Durability"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Concurrency Control",
    "question": "Which concurrency control mechanism uses locks to prevent multiple transactions from accessing the same data simultaneously?",
    "context": "Locking ensures concurrency control by granting exclusive or shared locks to transactions, preventing conflicts during simultaneous data access in a database.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Locking",
    "options": [
      "Timestamp Ordering",
      "Multiversion Concurrency Control",
      "Optimistic Concurrency Control",
      "Locking"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Indexing",
    "question": "Which type of index stores pointers to data records in a balanced tree structure to speed up search operations?",
    "context": "A B+ Tree Index organizes data in a balanced tree structure, with leaf nodes containing pointers to records, enabling efficient range queries and searches in databases.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "B+ Tree Index",
    "options": [
      "Hash Index",
      "B+ Tree Index",
      "Bitmap Index",
      "Inverted Index"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "File Organization",
    "question": "Which file organization method stores records in the order they are inserted, suitable for sequential access?",
    "context": "Heap File Organization stores records in the order of insertion without any specific sorting, making it efficient for sequential access but slower for searches without an index.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Heap File Organization",
    "options": [
      "Indexed File Organization",
      "Sequential File Organization",
      "Heap File Organization",
      "Clustered File Organization"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Concurrency Control",
    "question": "Which concurrency control protocol ensures serializability by assigning timestamps to transactions and ordering their operations?",
    "context": "The Timestamp Ordering Protocol assigns unique timestamps to transactions and ensures that operations are executed in timestamp order, guaranteeing serializability without locks.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Timestamp Ordering Protocol",
    "options": [
      "Optimistic Concurrency Control",
      "Multiversion Concurrency Control",
      "Two-Phase Locking",
      "Timestamp Ordering Protocol"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Indexing",
    "question": "Which indexing technique is most efficient for equality queries but inefficient for range queries due to its non-sequential structure?",
    "context": "A Hash Index uses a hash function to map keys to disk locations, providing O(1) average-case time for equality queries but performing poorly for range queries due to its non-sequential nature.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Hash Index",
    "options": [
      "Dense Index",
      "Bitmap Index",
      "B+ Tree Index",
      "Hash Index"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Transactions, Concurrency Control",
    "question": "In a highly concurrent database system handling online transactions, what is the primary purpose of a 'transaction' and the ACID properties it aims to guarantee?",
    "context": "A transaction is a single logical unit of work performed on a database. It's designed to ensure data integrity even in the face of concurrent access and system failures. The ACID properties (Atomicity, Consistency, Isolation, Durability) are a set of guarantees that a transaction processing system must meet to ensure data validity.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "A logical unit of work that ensures Atomicity, Consistency, Isolation, and Durability (ACID) for data integrity.",
    "options": [
      "A mechanism to backup and restore the entire database.",
      "A sequence of SQL queries executed by a single user.",
      "A logical unit of work that ensures Atomicity, Consistency, Isolation, and Durability (ACID) for data integrity.",
      "A way to improve the speed of individual queries through indexing."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Transactions, Concurrency Control",
    "question": "Consider two concurrent transactions, T1 and T2, where T1 reads a value, T2 updates it, and then T1 reads the value again, seeing a different value. What type of concurrency anomaly is this scenario an example of, and what isolation level aims to prevent it?",
    "context": "A non-repeatable read occurs when a transaction reads the same row twice but gets different values each time because another committed transaction modified that row between the two reads. The 'Read Committed' isolation level prevents dirty reads, but not non-repeatable reads. 'Repeatable Read' isolation level specifically aims to prevent non-repeatable reads by ensuring that a transaction sees the same data if it re-reads it.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Non-repeatable Read; Read Committed or higher (e.g., Repeatable Read).",
    "options": [
      "Phantom Read; Serializable.",
      "Dirty Read; Read Uncommitted.",
      "Lost Update; Read Committed.",
      "Non-repeatable Read; Read Committed or higher (e.g., Repeatable Read)."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Transactions, Concurrency Control",
    "question": "Two-Phase Locking (2PL) is a common concurrency control protocol. What is the primary property that 2PL ensures for concurrent transactions, and what is a potential drawback?",
    "context": "Two-Phase Locking (2PL) is a widely used concurrency control protocol that ensures serializability, meaning that concurrent transactions produce the same result as some serial execution of those transactions. It operates in two phases: a growing phase (acquiring locks) and a shrinking phase (releasing locks). A significant drawback of 2PL is its susceptibility to deadlocks, as transactions may hold locks and wait for others that are held by other waiting transactions.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Serializability; potential for deadlocks.",
    "options": [
      "Serializability; potential for deadlocks.",
      "Strict isolation; minimal overhead.",
      "High concurrency; guaranteed freedom from deadlocks.",
      "Reduced transaction rollback; increased throughput."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Indexing and File Organization",
    "question": "A database administrator needs to significantly speed up queries that involve searching for records based on a non-key attribute (e.g., finding all students whose 'major' is 'Computer Science'). Which type of index would be most appropriate for this scenario?",
    "context": "A secondary index is created on non-key attributes of a relation. It provides a way to access records quickly based on values in these attributes without requiring the table to be sorted. Unlike a primary or clustered index, a secondary index does not determine the physical order of data records, and there can be multiple secondary indexes on a single table.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Secondary Index",
    "options": [
      "Clustered Index",
      "Secondary Index",
      "Primary Index",
      "Hash Index"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Indexing and File Organization",
    "question": "What is the primary advantage of a 'clustered index' over a 'non-clustered index' in a relational database?",
    "context": "A clustered index defines the physical order of the data rows in the table. This means that when data is retrieved using the clustered index, the disk I/O operations are minimized, especially for range queries, as the data is already sorted and stored contiguously. A table can have only one clustered index.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "The data rows themselves are stored in the same physical order as the index, leading to faster retrieval for range queries.",
    "options": [
      "It allows for multiple clustered indexes on the same table.",
      "It is always faster for exact key lookups.",
      "It requires less disk space than a non-clustered index.",
      "The data rows themselves are stored in the same physical order as the index, leading to faster retrieval for range queries."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Database Management Systems",
    "subtopic": "Indexing and File Organization",
    "question": "A database needs to store customer records and frequently retrieve them based on their unique 'CustomerID'. Which file organization method directly supports fast retrieval of records based on the value of a key that is used to order the records physically?",
    "context": "Sequential file organization stores records in sequential order based on a search key (often the primary key). While it requires sorting, it allows for efficient retrieval of records based on that key, especially for range queries. A primary index is often built on top of a sequential file to quickly locate the starting block of records for a given key, providing faster direct access.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Sequential File Organization (with primary index)",
    "options": [
      "Heap File Organization",
      "Sequential File Organization (with primary index)",
      "Hash File Organization",
      "B+ Tree File Organization (if not primary key ordered)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "OSI and TCP/IP Models",
    "question": "Which layer of the OSI model is responsible for reliable end-to-end communication?",
    "context": "The Transport Layer ensures reliable end-to-end communication, flow control, and error handling in the OSI model.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Transport Layer",
    "options": [
      "Data Link Layer",
      "Network Layer",
      "Transport Layer",
      "Session Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "OSI and TCP/IP Models",
    "question": "Which protocol operates at the Network Layer of the TCP/IP model to route packets between devices?",
    "context": "IP (Internet Protocol) is a core protocol at the Network Layer in the TCP/IP model used for logical addressing and routing.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "IP",
    "options": [
      "HTTP",
      "IP",
      "TCP",
      "ARP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "Which routing algorithm updates the routing table based on the distance to the destination?",
    "context": "Distance Vector Routing calculates the best path by considering the number of hops to the destination and shares this information periodically.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Distance Vector Routing",
    "options": [
      "Static Routing",
      "Link State Routing",
      "Distance Vector Routing",
      "Flooding"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "Which algorithm uses the shortest path first method based on the entire network topology?",
    "context": "Link State Routing algorithms have complete knowledge of the network topology and use Dijkstra’s algorithm to compute the shortest paths.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Link State Routing",
    "options": [
      "Link State Routing",
      "Bellman-Ford Algorithm",
      "Path Vector Routing",
      "Distance Vector Routing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "Which congestion control mechanism in TCP increases the window size exponentially during the start of transmission?",
    "context": "TCP uses Slow Start to gradually increase the congestion window size to avoid sudden network congestion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Slow Start",
    "options": [
      "Slow Start",
      "Congestion Avoidance",
      "Fast Retransmit",
      "Additive Increase"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "What happens to the congestion window in TCP when a packet loss is detected?",
    "context": "TCP interprets packet loss as a sign of congestion and reduces the congestion window, often restarting with the slow start phase.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "The window size is reduced and slow start is reinitiated",
    "options": [
      "The connection is terminated",
      "The window size is doubled",
      "The window size is increased linearly",
      "The window size is reduced and slow start is reinitiated"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "Which technique is used in congestion control to notify the sender about congestion without dropping packets?",
    "context": "ECN is a network congestion avoidance mechanism that signals the sender to reduce transmission rate without dropping packets.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Explicit Congestion Notification (ECN)",
    "options": [
      "Explicit Congestion Notification (ECN)",
      "Slow Start",
      "AIMD",
      "Fast Recovery"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "OSI and TCP/IP Models",
    "subtopic": "Layer Functions",
    "question": "Which layer of the OSI model is responsible for end-to-end delivery of data segments?",
    "context": "The Transport Layer (Layer 4) in OSI model provides end-to-end communication services, including reliable data delivery, error recovery, and flow control between applications on different hosts.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Transport Layer",
    "options": [
      "Network Layer",
      "Session Layer",
      "Transport Layer",
      "Data Link Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "OSI and TCP/IP Models",
    "subtopic": "Protocol Mapping",
    "question": "Which TCP/IP layer corresponds to both Session and Presentation layers of OSI model?",
    "context": "TCP/IP model has fewer layers than OSI. The Application Layer in TCP/IP combines the functionality of Session, Presentation, and Application layers from the OSI model into a single layer.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Application Layer",
    "options": [
      "Network Interface Layer",
      "Transport Layer",
      "Application Layer",
      "Internet Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Routing Algorithms",
    "subtopic": "Distance Vector Routing",
    "question": "What is the main problem associated with Distance Vector routing protocol?",
    "context": "Distance Vector routing suffers from the count-to-infinity problem where bad news (link failures) propagates slowly through the network, causing routing loops and convergence delays.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Count-to-infinity problem",
    "options": [
      "Frequent topology broadcasts",
      "Count-to-infinity problem",
      "High memory overhead",
      "Complex computation requirements"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Routing Algorithms",
    "subtopic": "Link State Routing",
    "question": "Which algorithm is used by Link State routing protocols to calculate shortest paths?",
    "context": "Link State routing protocols like OSPF use Dijkstra's algorithm to compute shortest path tree from each node to all other nodes in the network topology database.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Dijkstra's algorithm",
    "options": [
      "Floyd-Warshall algorithm",
      "Dijkstra's algorithm",
      "Bellman-Ford algorithm",
      "Prim's algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Routing Algorithms",
    "subtopic": "BGP Protocol",
    "question": "What type of routing protocol is BGP (Border Gateway Protocol)?",
    "context": "BGP is a Path Vector protocol that maintains the path information (sequence of ASes) to reach each destination, preventing routing loops and enabling policy-based routing decisions.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Path Vector protocol",
    "options": [
      "Path Vector protocol",
      "Link State protocol",
      "Distance Vector protocol",
      "Hybrid protocol"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Congestion Control",
    "subtopic": "TCP Congestion Control",
    "question": "In TCP's congestion control, what happens to the congestion window when a timeout occurs?",
    "context": "When a timeout occurs in TCP, it indicates severe congestion. The congestion window is reset to 1 Maximum Segment Size (MSS) and the slow start phase begins to probe network capacity conservatively.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Reset to 1 MSS and slow start begins",
    "options": [
      "Reduced to half of current size",
      "Increased by 1 MSS",
      "Reset to 1 MSS and slow start begins",
      "Remains unchanged"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Congestion Control",
    "subtopic": "Active Queue Management",
    "question": "What is the primary advantage of Random Early Detection (RED) over traditional drop-tail queuing?",
    "context": "RED randomly drops packets before the queue becomes full, preventing global synchronization where multiple TCP connections simultaneously reduce their sending rates, leading to better network utilization.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Prevents global synchronization of TCP flows",
    "options": [
      "Reduces packet processing overhead",
      "Eliminates all packet drops",
      "Increases overall network throughput",
      "Prevents global synchronization of TCP flows"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "OSI Model",
    "question": "Which layer of the OSI model is responsible for establishing, maintaining, and terminating connections between devices?",
    "context": "The Session Layer (Layer 5) in the OSI model manages communication sessions, handling the setup, coordination, and termination of connections between applications.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Session Layer",
    "options": [
      "Application Layer",
      "Transport Layer",
      "Session Layer",
      "Network Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "TCP/IP Model",
    "question": "Which layer in the TCP/IP model corresponds to both the Network and Data Link layers of the OSI model?",
    "context": "The Internet Layer in the TCP/IP model handles packet routing and addressing, corresponding to the OSI model’s Network Layer (routing) and part of the Data Link Layer (logical addressing).",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Internet Layer",
    "options": [
      "Internet Layer",
      "Application Layer",
      "Link Layer",
      "Transport Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "Which routing algorithm calculates the shortest path to all destinations from a single source using a greedy approach?",
    "context": "Dijkstra’s Algorithm computes the shortest paths from a source to all other nodes in a weighted graph using a greedy approach, selecting the node with the smallest tentative distance.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Dijkstra’s Algorithm",
    "options": [
      "Bellman-Ford Algorithm",
      "Dijkstra’s Algorithm",
      "Distance Vector Routing",
      "Flooding"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "Which routing algorithm exchanges routing tables between neighboring routers to determine the best paths?",
    "context": "Distance Vector Routing involves routers sharing their routing tables with neighbors, using algorithms like Bellman-Ford to compute the least-cost paths based on hop distances.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Distance Vector Routing",
    "options": [
      "Distance Vector Routing",
      "Path Vector Protocol",
      "Link State Routing",
      "Flooding"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "Which congestion control mechanism in TCP adjusts the sending rate based on the detection of packet loss?",
    "context": "Additive Increase Multiplicative Decrease (AIMD) in TCP gradually increases the congestion window on successful delivery and reduces it multiplicatively upon packet loss to manage network congestion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Additive Increase Multiplicative Decrease",
    "options": [
      "Token Bucket",
      "Additive Increase Multiplicative Decrease",
      "Leaky Bucket",
      "Random Early Detection"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "Which congestion control algorithm proactively drops packets before the queue is full to signal congestion to senders?",
    "context": "Random Early Detection (RED) drops packets probabilistically as the queue approaches capacity, signaling senders to reduce their transmission rate, thus preventing severe congestion.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Random Early Detection",
    "options": [
      "Go-Back-N",
      "Random Early Detection",
      "Stop-and-Wait",
      "Sliding Window"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "Which routing protocol uses a shortest path first approach and floods link-state information to all routers in the network?",
    "context": "Open Shortest Path First (OSPF) is a link-state routing protocol that uses Dijkstra’s algorithm to compute shortest paths and floods link-state updates to maintain a consistent network topology.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "OSPF",
    "options": [
      "BGP",
      "OSPF",
      "EIGRP",
      "RIP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "OSI and TCP/IP Models",
    "question": "A network engineer is troubleshooting an issue where a client cannot establish a secure connection (HTTPS) to a web server. At which layer of the OSI model would the Secure Sockets Layer (SSL)/Transport Layer Security (TLS) protocol operate to provide encryption and authentication for this communication?",
    "context": "While TLS/SSL operates conceptually between the Application and Transport layers, within the strict seven-layer OSI model, its functions (encryption, compression, formatting) are often associated with the Presentation Layer. Some interpretations also place it as part of the Session Layer for connection establishment or even directly within the Application Layer. However, Presentation Layer is the most commonly accepted answer for its core role in data representation and security for the application.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Presentation Layer (or Session/Application depending on strict interpretation)",
    "options": [
      "Transport Layer",
      "Data Link Layer",
      "Presentation Layer (or Session/Application depending on strict interpretation)",
      "Network Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "OSI and TCP/IP Models",
    "question": "Which layer in the TCP/IP model is responsible for logical addressing (IP addresses) and routing packets across different networks (inter-networking)?",
    "context": "The Internet Layer (also known as the Network Layer in the OSI model) in the TCP/IP suite is responsible for the logical addressing of devices using IP addresses and for routing packets from the source host to the destination host across potentially multiple networks. This layer ensures end-to-end packet delivery.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Internet Layer",
    "options": [
      "Transport Layer",
      "Network Access Layer",
      "Application Layer",
      "Internet Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "In a large, complex network, a dynamic routing protocol is needed that can quickly adapt to changes in network topology and link costs, and compute the shortest path to all other nodes. Which type of routing algorithm, exemplified by OSPF, fits this description?",
    "context": "Link-State routing algorithms (like OSPF and IS-IS) require each router to have a complete map of the network topology. Routers exchange information about their directly connected links (link states). Each router then independently computes the shortest path to all other destinations using an algorithm like Dijkstra's. This provides fast convergence and robust adaptation to network changes.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Link-State Routing Algorithm",
    "options": [
      "Link-State Routing Algorithm",
      "Static Routing",
      "Flooding",
      "Distance-Vector Routing Algorithm"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Routing Algorithms",
    "question": "Which of the following routing algorithms uses Bellman-Ford's algorithm and relies on neighbors to exchange routing table information, potentially suffering from the 'count-to-infinity' problem?",
    "context": "Distance-Vector routing algorithms (like RIP - Routing Information Protocol) work by having each router maintain a routing table that contains the distance (cost) to all known destinations. Routers periodically exchange their entire routing tables with their directly connected neighbors. These algorithms use the Bellman-Ford equation. A significant drawback is their susceptibility to the 'count-to-infinity' problem in certain network topologies, which can lead to routing loops.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Distance-Vector Routing Algorithm (e.g., RIP)",
    "options": [
      "Distance-Vector Routing Algorithm (e.g., RIP)",
      "Border Gateway Protocol (BGP)",
      "Link-State Routing Algorithm (e.g., OSPF)",
      "Source Routing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "In the TCP protocol, when network congestion is detected (e.g., by packet loss), what is the primary mechanism TCP uses to reduce the amount of data injected into the network to alleviate the congestion?",
    "context": "TCP employs various congestion control mechanisms to prevent and react to network congestion. A key mechanism is the adjustment of the 'congestion window' (cwnd). When congestion is detected (typically through packet loss, inferred by timeouts or duplicate ACKs), TCP reduces the cwnd, thereby limiting the amount of data it sends into the network, thus easing the congestion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Reducing the Congestion Window (cwnd)",
    "options": [
      "Increasing the Receiver Window (rwnd).",
      "Switching to a different routing path.",
      "Reducing the Congestion Window (cwnd)",
      "Sending more packets with higher priority."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Congestion Control",
    "question": "TCP's congestion control mechanism involves both 'slow start' and 'congestion avoidance' phases. What is the main characteristic of the 'slow start' phase?",
    "context": "During the slow start phase, TCP starts with a small congestion window and increases it exponentially. For every Acknowledgment (ACK) received, the congestion window is increased by one Maximum Segment Size (MSS). This rapid growth continues until the congestion window reaches a 'slow start threshold' (ssthresh), at which point it transitions to the congestion avoidance phase.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Exponentially increasing the congestion window by one segment for every acknowledgment received.",
    "options": [
      "Immediately sending data at the maximum possible rate.",
      "Linearly increasing the congestion window by one segment per Round Trip Time (RTT).",
      "Maintaining a fixed congestion window size.",
      "Exponentially increasing the congestion window by one segment for every acknowledgment received."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "OSI and TCP/IP Models",
    "question": "A user is Browse a website, and their browser sends an HTTP request. Which layer in the TCP/IP model is directly responsible for handling this HTTP request and response, including the formatting of the application-specific data?",
    "context": "The Application Layer in the TCP/IP model is the topmost layer and interacts directly with user applications. Protocols like HTTP, FTP, SMTP, and DNS reside at this layer. Its responsibilities include data formatting, presentation, and all application-specific services that allow users to interact with the network.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Application Layer",
    "options": [
      "Transport Layer",
      "Internet Layer",
      "Network Access Layer",
      "Application Layer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "IPv4/IPv6",
    "question": "Which of the following features is supported in IPv6 but not in IPv4?",
    "context": "IPv6 supports a 128-bit address space, which is significantly larger than the 32-bit space in IPv4.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Larger address space",
    "options": [
      "Broadcast communication",
      "Larger address space",
      "ARP resolution",
      "Header checksum"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "DNS",
    "question": "Which service translates domain names to IP addresses in a computer network?",
    "context": "The Domain Name System (DNS) is responsible for resolving human-readable domain names into IP addresses.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "DNS",
    "options": [
      "ARP",
      "DHCP",
      "DNS",
      "NAT"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "DHCP",
    "question": "Which protocol is used to dynamically assign IP addresses to devices on a network?",
    "context": "DHCP (Dynamic Host Configuration Protocol) is used to automatically assign IP addresses and other network settings to devices.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "DHCP",
    "options": [
      "DHCP",
      "SMTP",
      "ICMP",
      "DNS"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "TCP vs UDP",
    "question": "Which protocol provides reliable, connection-oriented data delivery?",
    "context": "TCP ensures reliable data transfer with error checking, acknowledgments, and retransmissions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "TCP",
    "options": [
      "UDP",
      "TCP",
      "HTTP",
      "FTP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Application Layer Protocols",
    "question": "Which protocol is primarily used for sending emails?",
    "context": "SMTP (Simple Mail Transfer Protocol) is used to send email messages between servers.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "SMTP",
    "options": [
      "POP3",
      "SMTP",
      "FTP",
      "HTTP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "Application Layer Protocols",
    "question": "Which protocol is designed to transfer files between a client and server over a network?",
    "context": "FTP (File Transfer Protocol) enables the transfer of files between computers on a TCP/IP network.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "FTP",
    "options": [
      "FTP",
      "UDP",
      "SMTP",
      "DNS"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "IPv4/IPv6, DNS, DHCP",
    "subtopic": "IPv6 Addressing",
    "question": "What is the length of an IPv6 address in bits?",
    "context": "IPv6 addresses are 128 bits long, providing a much larger address space compared to IPv4's 32-bit addresses, allowing for approximately 3.4 × 10^38 unique addresses.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "128 bits",
    "options": [
      "32 bits",
      "256 bits",
      "128 bits",
      "64 bits"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "IPv4/IPv6, DNS, DHCP",
    "subtopic": "DNS Record Types",
    "question": "Which DNS record type is used to map a domain name to an IPv6 address?",
    "context": "AAAA records in DNS are used to map domain names to IPv6 addresses, similar to how A records map domain names to IPv4 addresses, supporting the transition to IPv6.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "AAAA record",
    "options": [
      "MX record",
      "AAAA record",
      "A record",
      "CNAME record"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "IPv4/IPv6, DNS, DHCP",
    "subtopic": "DHCP Process",
    "question": "What is the correct sequence of messages in the DHCP lease process?",
    "context": "DHCP follows a four-step process: client sends DISCOVER to find servers, server responds with OFFER, client sends REQUEST to accept, and server confirms with ACK message.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "DISCOVER, OFFER, REQUEST, ACK",
    "options": [
      "DISCOVER, REQUEST, OFFER, ACK",
      "REQUEST, OFFER, DISCOVER, ACK",
      "DISCOVER, OFFER, REQUEST, ACK",
      "OFFER, DISCOVER, ACK, REQUEST"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "TCP, UDP, HTTP, FTP, SMTP",
    "subtopic": "TCP vs UDP",
    "question": "Which characteristic distinguishes TCP from UDP?",
    "context": "TCP is connection-oriented and provides reliability through acknowledgments, retransmissions, and flow control, while UDP is connectionless and offers no delivery guarantees but with lower overhead.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Connection-oriented with reliability guarantees",
    "options": [
      "Faster data transmission",
      "Broadcast and multicast support",
      "Lower header overhead",
      "Connection-oriented with reliability guarantees"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "TCP, UDP, HTTP, FTP, SMTP",
    "subtopic": "HTTP Status Codes",
    "question": "What does HTTP status code 404 indicate?",
    "context": "HTTP 404 status code indicates that the server cannot find the requested resource, meaning the URL is invalid or the resource has been moved or deleted from the server.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Requested resource not found on server",
    "options": [
      "Unauthorized access attempt",
      "Server internal error",
      "Request timeout occurred",
      "Requested resource not found on server"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "TCP, UDP, HTTP, FTP, SMTP",
    "subtopic": "SMTP Protocol",
    "question": "Which port number is typically used by SMTP for sending emails?",
    "context": "SMTP (Simple Mail Transfer Protocol) typically uses port 25 for sending emails between mail servers, while port 587 is used for email submission from clients to servers with authentication.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "25",
    "options": [
      "25",
      "80",
      "21",
      "110"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "IPv4/IPv6",
    "question": "Which protocol version uses a 128-bit address space to overcome the address exhaustion problem of its predecessor?",
    "context": "IPv6 uses a 128-bit address space, providing a vastly larger number of addresses compared to IPv4’s 32-bit addresses, addressing the issue of address exhaustion in modern networks.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "IPv6",
    "options": [
      "ICMP",
      "IPv4",
      "IPv6",
      "ARP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "DNS",
    "question": "Which protocol is used to translate domain names into IP addresses in a network?",
    "context": "The Domain Name System (DNS) resolves human-readable domain names (e.g., www.example.com) into IP addresses, enabling communication between devices on the internet.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "DNS",
    "options": [
      "NTP",
      "DHCP",
      "SNMP",
      "DNS"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "DHCP",
    "question": "Which protocol dynamically assigns IP addresses to devices in a network?",
    "context": "The Dynamic Host Configuration Protocol (DHCP) automatically assigns IP addresses and network configuration parameters to devices, simplifying network management.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "DHCP",
    "options": [
      "RARP",
      "DHCP",
      "DNS",
      "BOOTP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "TCP",
    "question": "Which transport layer protocol provides reliable, connection-oriented data transmission with flow control?",
    "context": "Transmission Control Protocol (TCP) ensures reliable data delivery through connection establishment, error checking, and flow control, suitable for applications requiring guaranteed delivery.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "TCP",
    "options": [
      "UDP",
      "SCTP",
      "ICMP",
      "TCP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "UDP",
    "question": "Which protocol is best suited for real-time applications like video streaming due to its low overhead and lack of retransmission?",
    "context": "User Datagram Protocol (UDP) is a connectionless protocol with minimal overhead, ideal for real-time applications like video streaming where speed is prioritized over reliability.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "UDP",
    "options": [
      "RTP",
      "HTTP",
      "TCP",
      "UDP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "HTTP",
    "question": "Which application layer protocol uses a stateless, request-response model to retrieve web resources?",
    "context": "Hypertext Transfer Protocol (HTTP) operates at the application layer, using a stateless request-response model to retrieve web resources like HTML pages, commonly used in web browsers.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "HTTP",
    "options": [
      "Telnet",
      "SMTP",
      "FTP",
      "HTTP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "IPv4/IPv6, DNS, DHCP",
    "question": "A large organization is deploying a new network and faces the challenge of IP address depletion with IPv4. Which version of the Internet Protocol offers a significantly larger address space to accommodate the growing number of connected devices globally?",
    "context": "IPv4 uses 32-bit addresses, allowing for approximately 4.3 billion unique addresses, which are rapidly depleting. IPv6, on the other hand, uses 128-bit addresses, providing an astronomically larger address space (2^128 unique addresses), designed to overcome the limitations of IPv4 and support the vast expansion of the internet and IoT devices.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "IPv6",
    "options": [
      "ARP (Address Resolution Protocol)",
      "IPv6",
      "IPv4 with NAT",
      "ICMP (Internet Control Message Protocol)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "IPv4/IPv6, DNS, DHCP",
    "question": "When a new device connects to a network and needs to automatically obtain an IP address, subnet mask, default gateway, and DNS server addresses, which protocol is typically used for this dynamic configuration?",
    "context": "DHCP (Dynamic Host Configuration Protocol) is a network management protocol used on Internet Protocol (IP) networks for dynamically distributing network configuration parameters, such as IP addresses, to devices connected to the network. This automation simplifies network administration and allows devices to seamlessly join and leave the network.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "DHCP (Dynamic Host Configuration Protocol)",
    "options": [
      "ARP (Address Resolution Protocol)",
      "DHCP (Dynamic Host Configuration Protocol)",
      "ICMP (Internet Control Message Protocol)",
      "DNS (Domain Name System)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "TCP, UDP, HTTP, FTP, SMTP",
    "question": "For a video streaming application where real-time delivery and minimal delay are more critical than guaranteeing every single packet arrives, which transport layer protocol would be more suitable?",
    "context": "UDP is a connectionless and unreliable transport layer protocol. It provides minimal services compared to TCP, such as no guaranteed delivery, no flow control, and no congestion control. However, its simplicity and lower overhead make it ideal for applications where speed and low latency are prioritized over absolute reliability, such as real-time video streaming, online gaming, and DNS lookups.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "UDP (User Datagram Protocol)",
    "options": [
      "HTTP (Hypertext Transfer Protocol)",
      "SCTP (Stream Control Transmission Protocol)",
      "UDP (User Datagram Protocol)",
      "TCP (Transmission Control Protocol)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "TCP, UDP, HTTP, FTP, SMTP",
    "question": "A web browser sends a request to a web server to retrieve a webpage. Which application layer protocol is used for this communication, and what transport layer protocol does it typically rely on for reliable data transfer?",
    "context": "HTTP (Hypertext Transfer Protocol) is the foundation of data communication for the World Wide Web, used for fetching resources like HTML documents. HTTP is an application layer protocol that relies on TCP (Transmission Control Protocol) at the transport layer to provide reliable, ordered, and error-checked delivery of data streams between the client and server.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "HTTP, relying on TCP",
    "options": [
      "FTP, relying on UDP",
      "DNS, relying on UDP",
      "HTTP, relying on TCP",
      "SMTP, relying on TCP"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "IPv4/IPv6, DNS, DHCP",
    "question": "Before a web browser can connect to 'www.example.com', it needs to translate the human-readable domain name into an IP address. Which hierarchical and distributed network service is responsible for this translation?",
    "context": "DNS (Domain Name System) is a distributed naming system for computers, services, or any resource connected to the Internet or a private network. It translates easily memorized domain names (like 'www.example.com') into numerical IP addresses, which are necessary for locating and identifying computer services and devices with the underlying network protocols.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "DNS (Domain Name System)",
    "options": [
      "ARP (Address Resolution Protocol)",
      "DHCP (Dynamic Host Configuration Protocol)",
      "DNS (Domain Name System)",
      "NAT (Network Address Translation)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Networks",
    "subtopic": "TCP, UDP, HTTP, FTP, SMTP",
    "question": "A software developer is implementing a file transfer utility that requires guaranteed delivery of data, flow control, and congestion control to ensure reliable and efficient transmission of large files over a network. Which transport layer protocol should be chosen for this application?",
    "context": "TCP (Transmission Control Protocol) is a connection-oriented, reliable transport layer protocol. It provides features like guaranteed delivery of data, in-order packet delivery, flow control (preventing a fast sender from overwhelming a slow receiver), and congestion control (adapting to network conditions). These features are crucial for applications where data integrity and reliability are paramount, such as file transfers (FTP, HTTP) and email (SMTP).",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "TCP (Transmission Control Protocol)",
    "options": [
      "UDP (User Datagram Protocol)",
      "RTP (Real-time Transport Protocol)",
      "TCP (Transmission Control Protocol)",
      "ICMP (Internet Control Message Protocol)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Number Systems",
    "question": "Which number system uses only the digits 0 and 1 and is fundamental to digital electronics?",
    "context": "Binary number system, using only 0s and 1s, is the foundation of all digital systems.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Binary",
    "options": [
      "Decimal",
      "Hexadecimal",
      "Octal",
      "Binary"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "ALU Design",
    "question": "What is the primary function of an Arithmetic Logic Unit (ALU)?",
    "context": "The ALU performs all arithmetic and logic operations in a CPU.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "To perform arithmetic and logical operations",
    "options": [
      "To store data",
      "To manage memory",
      "To perform arithmetic and logical operations",
      "To decode instructions"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Instruction Formats",
    "question": "In which instruction format are both operands specified directly in the instruction?",
    "context": "Register addressing format specifies both operands within registers directly in the instruction.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Register addressing",
    "options": [
      "Register addressing",
      "Indexed addressing",
      "Indirect addressing",
      "Immediate addressing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Pipelining",
    "question": "What is a major advantage of pipelining in a processor?",
    "context": "Pipelining increases instruction throughput by overlapping execution phases of multiple instructions.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Increased instruction throughput",
    "options": [
      "Elimination of cache",
      "Reduced memory size",
      "Increased instruction throughput",
      "Simplified control unit"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Instruction Formats",
    "question": "Which field in an instruction format typically holds the operation to be performed?",
    "context": "The opcode field in an instruction specifies the operation to be performed.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Opcode field",
    "options": [
      "Operand field",
      "Status field",
      "Address field",
      "Opcode field"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Pipelining",
    "question": "Which type of pipeline hazard occurs when an instruction depends on the result of a previous instruction?",
    "context": "Data hazards occur in pipelining when instructions that exhibit data dependency are executed concurrently.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Data hazard",
    "options": [
      "Control hazard",
      "Data hazard",
      "Structural hazard",
      "Fetch hazard"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "ALU Design",
    "question": "Which component is used in ALUs to determine the sign of the result in arithmetic operations?",
    "context": "The sign bit in the result determines whether the output is positive or negative.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Sign bit",
    "options": [
      "Carry flag",
      "Instruction register",
      "Overflow flag",
      "Sign bit"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Number Systems, ALU Design",
    "subtopic": "Two's Complement",
    "question": "What is the range of numbers that can be represented using 8-bit two's complement notation?",
    "context": "In n-bit two's complement representation, the range is from -2^(n-1) to 2^(n-1)-1. For 8 bits, this gives -2^7 to 2^7-1, which is -128 to +127.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "-128 to +127",
    "options": [
      "-255 to +255",
      "-128 to +127",
      "-127 to +128",
      "0 to 255"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Number Systems, ALU Design",
    "subtopic": "ALU Operations",
    "question": "Which ALU operation is typically used to implement multiplication of two numbers by repeated addition?",
    "context": "Shift and Add method implements multiplication by examining each bit of the multiplier and performing addition and left shifts, effectively performing repeated addition with positional scaling.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Shift and Add",
    "options": [
      "Wallace Tree",
      "Carry Save Addition",
      "Booth's Algorithm",
      "Shift and Add"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Number Systems, ALU Design",
    "subtopic": "Floating Point Representation",
    "question": "In IEEE 754 single precision format, how many bits are allocated for the exponent field?",
    "context": "IEEE 754 single precision (32-bit) format allocates 1 bit for sign, 8 bits for exponent, and 23 bits for mantissa, allowing representation of a wide range of floating-point numbers.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "8 bits",
    "options": [
      "8 bits",
      "23 bits",
      "11 bits",
      "1 bit"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Instruction Formats",
    "subtopic": "Addressing Modes",
    "question": "In which addressing mode is the operand's address calculated by adding a constant to a register's content?",
    "context": "Indexed addressing mode calculates the effective address by adding a displacement or index value to the contents of a base register, commonly used for array access and data structure traversal.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Indexed addressing",
    "options": [
      "Direct addressing",
      "Indexed addressing",
      "Register indirect addressing",
      "Immediate addressing"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Instruction Formats",
    "subtopic": "RISC vs CISC",
    "question": "What is a characteristic feature of RISC (Reduced Instruction Set Computer) architecture?",
    "context": "RISC architecture uses fixed-length instruction formats to simplify instruction decoding and enable efficient pipelining, contrasting with CISC's variable-length instructions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Fixed-length instruction format",
    "options": [
      "Complex addressing modes",
      "Microcode-based instruction execution",
      "Fixed-length instruction format",
      "Variable-length instruction format"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Pipelining",
    "subtopic": "Pipeline Hazards",
    "question": "What type of hazard occurs when an instruction depends on the result of a previous instruction that hasn't completed execution?",
    "context": "Data hazards, specifically Read-After-Write (RAW) dependencies, occur when an instruction needs data from a previous instruction that hasn't finished writing its result, requiring pipeline stalling or forwarding.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Data hazard (RAW dependency)",
    "options": [
      "Structural hazard",
      "Control hazard",
      "Cache miss hazard",
      "Data hazard (RAW dependency)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Pipelining",
    "subtopic": "Pipeline Performance",
    "question": "In a 5-stage pipeline with 10 instructions and no hazards, what is the total number of clock cycles required?",
    "context": "Pipeline execution time = (Number of stages - 1) + Number of instructions. For 5 stages and 10 instructions: (5-1) + 10 = 14 cycles, assuming no stalls or hazards.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "14 cycles",
    "options": [
      "10 cycles",
      "15 cycles",
      "50 cycles",
      "14 cycles"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Number Systems",
    "question": "Which number system uses 16 distinct symbols to represent values, commonly used in memory addresses?",
    "context": "The hexadecimal number system uses 16 symbols (0-9 and A-F) to represent values, widely used in computing for compact representation of memory addresses and binary data.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Hexadecimal",
    "options": [
      "Decimal",
      "Hexadecimal",
      "Octal",
      "Binary"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Number Systems",
    "question": "Which representation is used to store negative integers using a fixed number of bits, with the most significant bit indicating the sign?",
    "context": "Sign-Magnitude representation uses the most significant bit to indicate the sign (0 for positive, 1 for negative) and the remaining bits for the magnitude, commonly used in early computer systems.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Sign-Magnitude",
    "options": [
      "Gray Code",
      "Sign-Magnitude",
      "One’s Complement",
      "Two’s Complement"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "ALU Design",
    "question": "Which component of the ALU performs logical operations like AND, OR, and NOT on binary inputs?",
    "context": "The Logic Unit in the Arithmetic Logic Unit (ALU) handles logical operations such as AND, OR, and NOT, enabling bitwise computations essential for processing in CPUs.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Logic Unit",
    "options": [
      "Control Unit",
      "Arithmetic Unit",
      "Logic Unit",
      "Shift Unit"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Instruction Formats",
    "question": "Which instruction format uses a fixed number of bits for the opcode and allocates remaining bits for operands and addressing modes?",
    "context": "Fixed-Length Instruction Format uses a consistent number of bits for each instruction, simplifying decoding in pipelined architectures but potentially wasting space for simple operations.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Fixed-Length Instruction Format",
    "options": [
      "RISC Instruction Format",
      "Fixed-Length Instruction Format",
      "Variable-Length Instruction Format",
      "CISC Instruction Format"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Pipelining",
    "question": "Which pipelining hazard occurs when an instruction depends on the result of a previous instruction that is still in the pipeline?",
    "context": "A Data Hazard occurs in pipelining when an instruction requires data that a previous instruction, still in the pipeline, has not yet produced, potentially causing incorrect execution.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Data Hazard",
    "options": [
      "Control Hazard",
      "Instruction Hazard",
      "Structural Hazard",
      "Data Hazard"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "ALU Design",
    "question": "Which ALU operation requires a carry-in bit to handle multi-bit addition correctly?",
    "context": "A Full Adder in the ALU performs binary addition on two bits and a carry-in bit, producing a sum and carry-out, essential for multi-bit arithmetic operations in processors.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Full Adder",
    "options": [
      "Multiplexer",
      "Comparator",
      "Half Adder",
      "Full Adder"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Pipelining",
    "question": "Which technique resolves control hazards in pipelining by predicting the outcome of a branch instruction?",
    "context": "Branch Prediction anticipates the outcome of branch instructions to keep the pipeline full, reducing stalls caused by control hazards, with techniques like static or dynamic prediction.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Branch Prediction",
    "options": [
      "Out-of-Order Execution",
      "Branch Prediction",
      "Data Forwarding",
      "Cache Coherence"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Number Systems, ALU Design",
    "question": "A digital circuit needs to perform binary subtraction using 2's complement arithmetic. If a number is represented by 'n' bits, what is the range of signed integers that can be represented using this method?",
    "context": "Two's complement is the most common method of representing signed integers in computer systems. For an n-bit representation, one bit is used for the sign (most significant bit), and the remaining n-1 bits represent the magnitude. This allows for an asymmetric range from $-2^{n-1}$ to $2^{n-1} - 1$, with one more negative number than positive numbers.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "$-2^{n-1}$ to $2^{n-1} - 1$",
    "options": [
      "$-2^{n-1}$ to $2^{n-1} - 1$",
      "$-2^{n-1} + 1$ to $2^{n-1}$",
      "$-2^n$ to $2^n$",
      "$0$ to $2^n - 1$"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Number Systems, ALU Design",
    "question": "In the design of an Arithmetic Logic Unit (ALU), what is the primary advantage of using a 'Carry-Lookahead Adder' compared to a 'Ripple-Carry Adder' for performing binary addition?",
    "context": "A Ripple-Carry Adder suffers from a long propagation delay because the carry-out of each full adder stage must ripple through to the next stage sequentially. A Carry-Lookahead Adder solves this by generating carry signals in parallel, based on the input bits and initial carry, thereby dramatically speeding up addition for larger word lengths. This is crucial for high-performance processors.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Significantly faster addition by computing carries in parallel, reducing propagation delay.",
    "options": [
      "Handles floating-point numbers more efficiently.",
      "Requires less hardware (fewer logic gates).",
      "Significantly faster addition by computing carries in parallel, reducing propagation delay.",
      "Simpler design and implementation."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Instruction Formats",
    "question": "A computer architecture uses a 'three-address instruction' format. What is the typical structure and benefit of this format compared to single-address or two-address formats?",
    "context": "In a three-address instruction format, an instruction typically has the form `OPCODE Destination, Source1, Source2`. This means operations can often be performed with a single instruction, directly using two source values and storing the result in a designated destination. This reduces the total number of instructions needed for complex expressions, potentially simplifying compiler design and improving code density compared to formats that use fewer explicit operands.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Each instruction specifies two source operands and one destination operand, reducing the number of instructions per operation.",
    "options": [
      "Each instruction specifies one source and one destination, requiring an extra register for temporary results.",
      "Each instruction specifies two source operands and one destination operand, reducing the number of instructions per operation.",
      "Each instruction specifies only one operand, relying heavily on an accumulator.",
      "Instructions are always fixed-length, simplifying decoding but limiting operand flexibility."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Instruction Formats",
    "question": "An embedded system's processor design prioritizes code density and minimal instruction decoding hardware. Which instruction format would be most suitable, typically seen in stack-based architectures, minimizing explicit operand addresses?",
    "context": "In a zero-address (or stack-based) instruction format, operations implicitly take their operands from the top of a stack and push the result back onto the stack. This eliminates the need for explicit operand addresses in the instruction itself, leading to very compact code and simpler instruction decoding logic. While it requires a stack for operations, it's effective for code density in certain architectures.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Zero-address instruction format (Stack-based)",
    "options": [
      "Three-address instruction format",
      "Two-address instruction format",
      "One-address (Accumulator-based) instruction format",
      "Zero-address instruction format (Stack-based)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Pipelining",
    "question": "A CPU uses a 5-stage instruction pipeline (Fetch, Decode, Execute, Memory Access, Write Back). If two consecutive instructions are `ADD R1, R2, R3` and `SUB R4, R1, R5`, what type of hazard is most likely to occur, and how is it typically resolved?",
    "context": "A data hazard (specifically, a Read-After-Write, or RAW, dependence) occurs when an instruction tries to read a register before a preceding instruction has written to it. In the given example, `SUB` needs the value of `R1` which is written by `ADD`. This is typically resolved by 'forwarding' (or 'bypassing'), where the result of the `ADD` instruction is forwarded directly from the execution stage to the execution stage of the `SUB` instruction, avoiding a stall, or by inserting stall cycles if forwarding isn't possible.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Data Hazard (RAW dependence); using forwarding/bypassing or stalls.",
    "options": [
      "Control Hazard; using branch prediction.",
      "Data Hazard (RAW dependence); using forwarding/bypassing or stalls.",
      "Structural Hazard; by providing more hardware resources.",
      "Instruction Hazard; by pre-fetching instructions."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Pipelining",
    "question": "What is the primary goal of implementing a pipeline in a CPU architecture?",
    "context": "Pipelining is a technique that divides the execution of an instruction into multiple stages (e.g., fetch, decode, execute). By allowing different stages of different instructions to execute concurrently, pipelining increases the 'throughput' (number of instructions completed per unit of time) of the CPU, even though the 'latency' (time for a single instruction to complete) might not decrease.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To increase the throughput of instructions by overlapping their execution phases.",
    "options": [
      "To increase the throughput of instructions by overlapping their execution phases.",
      "To reduce the latency of individual instructions.",
      "To decrease the total power consumption of the CPU.",
      "To simplify the instruction set architecture (ISA)."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Pipelining",
    "question": "A CPU pipeline is designed to have multiple stages. What is the maximum theoretical speedup achievable by an N-stage ideal pipeline compared to a non-pipelined processor for a long sequence of instructions?",
    "context": "In an ideal N-stage pipeline, after the initial N-1 cycles to fill the pipeline, one instruction completes every clock cycle. A non-pipelined processor completes one instruction every N clock cycles. Therefore, for a sufficiently long sequence of instructions, the theoretical speedup is N times. In reality, hazards and imbalances between stages reduce this ideal speedup.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "N times",
    "options": [
      "N/2 times",
      "Log(N) times",
      "N times",
      "2N times"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Memory Hierarchy",
    "question": "Which level of memory in a computer system is the fastest but smallest in size?",
    "context": "Cache memory is the fastest memory in the hierarchy, used to store frequently accessed data.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Cache memory",
    "options": [
      "Main memory",
      "Virtual memory",
      "Secondary memory",
      "Cache memory"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Memory Hierarchy",
    "question": "What is the primary purpose of virtual memory?",
    "context": "Virtual memory allows programs to use more memory than physically available by using disk space.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "To give an illusion of a large main memory",
    "options": [
      "To store cache data",
      "To increase CPU speed",
      "To backup RAM",
      "To give an illusion of a large main memory"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "I/O Organization",
    "question": "Which technique is used to transfer data directly between an I/O device and memory?",
    "context": "DMA allows devices to bypass the CPU and directly transfer data to/from memory, improving efficiency.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Direct Memory Access (DMA)",
    "options": [
      "Memory-mapped I/O",
      "Direct Memory Access (DMA)",
      "Programmed I/O",
      "Interrupt-driven I/O"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "RISC vs CISC",
    "question": "Which architecture uses a small set of simple instructions and aims for faster execution per instruction?",
    "context": "RISC (Reduced Instruction Set Computer) focuses on simple instructions for faster performance.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "RISC",
    "options": [
      "RISC",
      "x86",
      "CISC",
      "MIPS"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "RISC vs CISC",
    "question": "Which of the following is a feature of CISC architecture?",
    "context": "CISC architecture supports complex instructions that perform multiple tasks, reducing code size.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Instructions can perform multiple operations",
    "options": [
      "Each instruction is one clock cycle",
      "Instructions can perform multiple operations",
      "No microcode usage",
      "All instructions take the same time"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "I/O Organization",
    "question": "In interrupt-driven I/O, what happens when an I/O operation completes?",
    "context": "Interrupt-driven I/O allows the CPU to be interrupted upon I/O completion, improving efficiency over polling.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "CPU is interrupted to handle the I/O completion",
    "options": [
      "Instruction cache is flushed",
      "CPU is interrupted to handle the I/O completion",
      "DMA starts automatically",
      "CPU polls the device"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Memory Hierarchy",
    "question": "Which memory level is used when data is not found in the cache?",
    "context": "If data is not found in the cache, the system fetches it from the slower main memory.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Main memory",
    "options": [
      "Register",
      "Hard disk",
      "ROM",
      "Main memory"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Memory Hierarchy",
    "subtopic": "Cache Memory",
    "question": "What is the primary advantage of direct-mapped cache over fully associative cache?",
    "context": "Direct-mapped cache uses simple hardware with only one possible location for each memory block, enabling faster access time compared to fully associative cache which requires complex comparison logic for all cache lines.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Faster access time due to simpler hardware",
    "options": [
      "Better cache utilization",
      "Faster access time due to simpler hardware",
      "Reduced cache coherence overhead",
      "Lower miss rate"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Memory Hierarchy",
    "subtopic": "Virtual Memory",
    "question": "What happens when a page fault occurs in virtual memory system?",
    "context": "A page fault occurs when a program references a page not currently in main memory, triggering the operating system to load the required page from secondary storage into main memory.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Operating system loads the required page from secondary storage",
    "options": [
      "Operating system loads the required page from secondary storage",
      "Program execution terminates with error",
      "Cache memory is flushed automatically",
      "Virtual address is converted to physical address"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Memory Hierarchy",
    "subtopic": "Cache Performance",
    "question": "If a cache has a hit rate of 90% with access time 2ns, and main memory access time is 100ns, what is the average memory access time?",
    "context": "Average Memory Access Time = Hit Rate × Cache Access Time + Miss Rate × (Cache Access Time + Main Memory Access Time). AMAT = 0.9×2 + 0.1×(2+100) = 1.8 + 10.2 = 12ns.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "12ns",
    "options": [
      "20ns",
      "12ns",
      "10ns",
      "102ns"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "I/O Organization",
    "subtopic": "DMA Transfer",
    "question": "What is the main benefit of DMA (Direct Memory Access) over programmed I/O?",
    "context": "DMA allows I/O devices to transfer data directly to/from memory without CPU intervention, freeing the CPU to perform other tasks while data transfer occurs in parallel.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "CPU is freed from data transfer operations",
    "options": [
      "Higher data transfer speed",
      "CPU is freed from data transfer operations",
      "Lower power consumption",
      "Better error detection capability"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "I/O Organization",
    "subtopic": "Interrupt Handling",
    "question": "In interrupt-driven I/O, what determines the order in which multiple simultaneous interrupts are serviced?",
    "context": "Interrupt priority levels determine the order of interrupt servicing when multiple interrupts occur simultaneously, with higher priority interrupts preempting lower priority ones.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Interrupt priority levels",
    "options": [
      "First-come-first-served basis",
      "Interrupt priority levels",
      "Program execution order",
      "Device access speed"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "RISC vs CISC",
    "subtopic": "Instruction Characteristics",
    "question": "Which characteristic is typical of CISC (Complex Instruction Set Computer) architecture?",
    "context": "CISC architectures use variable-length instruction encoding to accommodate complex instructions with different operand types and addressing modes, contrasting with RISC's fixed-length instructions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Variable-length instruction encoding",
    "options": [
      "Variable-length instruction encoding",
      "Large number of general-purpose registers",
      "Single-cycle instruction execution",
      "Load-store architecture"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "RISC vs CISC",
    "subtopic": "Performance Comparison",
    "question": "Why do RISC processors typically achieve better performance in pipelined execution compared to CISC processors?",
    "context": "RISC processors have uniform, simple instructions that execute in predictable time, making pipeline design more efficient compared to CISC's variable execution time instructions that complicate pipeline timing.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Uniform instruction execution time enables efficient pipelining",
    "options": [
      "Larger cache memory sizes",
      "Higher clock frequency capabilities",
      "Better branch prediction accuracy",
      "Uniform instruction execution time enables efficient pipelining"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Memory Hierarchy",
    "question": "Which level of the memory hierarchy provides the fastest access time but has the smallest storage capacity?",
    "context": "Cache Memory is a small, fast memory located close to the CPU, used to store frequently accessed data, providing the fastest access time but limited by its high cost and small capacity.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Cache Memory",
    "options": [
      "Secondary Memory",
      "Virtual Memory",
      "Main Memory",
      "Cache Memory"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Memory Hierarchy",
    "question": "Which memory management technique uses a page table to map logical addresses to physical addresses?",
    "context": "Virtual Memory uses a page table to map logical addresses to physical addresses, allowing processes to use more memory than physically available by swapping data to disk.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Virtual Memory",
    "options": [
      "Virtual Memory",
      "Cache Memory",
      "Register Memory",
      "Main Memory"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "I/O Organization",
    "question": "Which I/O technique allows the CPU to continue processing while the I/O device operates independently?",
    "context": "Direct Memory Access (DMA) enables I/O devices to transfer data directly to or from memory without CPU intervention, improving efficiency for large data transfers.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Direct Memory Access",
    "options": [
      "Programmed I/O",
      "Polling",
      "Direct Memory Access",
      "Interrupt-Driven I/O"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "I/O Organization",
    "question": "Which mechanism is used to signal the CPU when an I/O device needs attention?",
    "context": "An Interrupt is a signal sent by an I/O device to the CPU to indicate that it requires attention, allowing the CPU to handle I/O events asynchronously.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Interrupt",
    "options": [
      "Cache Coherence",
      "Memory Mapping",
      "Bus Arbitration",
      "Interrupt"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "Memory Hierarchy",
    "question": "Which cache mapping technique stores a block in any cache line, requiring a tag to identify the memory address?",
    "context": "Fully Associative Mapping allows a memory block to be placed in any cache line, using a tag to identify the block’s address, maximizing flexibility but increasing search time.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Fully Associative Mapping",
    "options": [
      "Direct Mapping",
      "Write-Through Mapping",
      "Fully Associative Mapping",
      "Set-Associative Mapping"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "RISC vs CISC",
    "question": "Which processor architecture uses a small set of simple, fixed-length instructions to improve execution speed?",
    "context": "Reduced Instruction Set Computing (RISC) uses a small, uniform set of fixed-length instructions, enabling faster execution through simplified decoding and pipelining.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "RISC",
    "options": [
      "CISC",
      "EPIC",
      "VLIW",
      "RISC"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Organization",
    "subtopic": "RISC vs CISC",
    "question": "Which processor architecture supports complex instructions that may take multiple cycles to execute, reducing the number of instructions needed?",
    "context": "Complex Instruction Set Computing (CISC) supports complex, variable-length instructions that can perform multiple operations, reducing the number of instructions but complicating pipelining.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "CISC",
    "options": [
      "CISC",
      "RISC",
      "MIPS",
      "ARM"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Memory Hierarchy (Cache, Main, Virtual)",
    "question": "A modern CPU uses a multi-level cache hierarchy. What is the primary purpose of introducing multiple levels of cache (e.g., L1, L2, L3) between the CPU and main memory?",
    "context": "The memory hierarchy (cache, main memory, secondary storage) is designed to bridge the speed gap between the fast CPU and slow main memory. Multiple levels of cache (L1 being fastest and smallest, L3 being slowest and largest) exploit the principles of locality (temporal and spatial) to ensure that frequently and recently accessed data is closer to the CPU, thereby significantly reducing the average memory access time.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To reduce the average memory access time by exploiting spatial and temporal locality.",
    "options": [
      "To reduce the average memory access time by exploiting spatial and temporal locality.",
      "To eliminate the need for virtual memory.",
      "To increase the total physical memory capacity of the system.",
      "To directly connect all I/O devices to the CPU."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Memory Hierarchy (Cache, Main, Virtual)",
    "question": "In a paged virtual memory system, a 'page fault' occurs. What does this event signify, and what action does the operating system typically take in response?",
    "context": "A page fault is an exception raised by the hardware when a program tries to access a memory page that is currently not loaded into physical memory (RAM). In response, the operating system's virtual memory manager traps the fault, locates the requested page on secondary storage (like a hard disk), loads it into an available physical memory frame, updates the page table, and then resumes the interrupted program.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "The requested page is not in physical memory; the OS loads the page from secondary storage into a free frame.",
    "options": [
      "The cache has experienced a miss, and the data is fetched from main memory.",
      "The program has run out of available virtual address space.",
      "The requested page is not in physical memory; the OS loads the page from secondary storage into a free frame.",
      "The CPU has detected an illegal memory access, causing a program termination."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "Memory Hierarchy (Cache, Main, Virtual)",
    "question": "Which cache mapping technique allows a memory block to be placed in *any* line of the cache, offering the greatest flexibility but requiring the most complex hardware for tag comparison?",
    "context": "In fully associative cache mapping, any block from main memory can be placed in any cache line. This provides the highest flexibility and potentially the lowest conflict misses. However, it requires a comparator for each cache line to check if the requested block is present, leading to complex and expensive hardware for larger caches.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Fully Associative Mapping",
    "options": [
      "Indexed Mapping",
      "Set-Associative Mapping",
      "Fully Associative Mapping",
      "Direct Mapping"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "I/O Organization",
    "question": "A high-performance storage system needs to transfer large blocks of data between a disk controller and main memory without continuous CPU intervention. What I/O technique is specifically designed for this purpose, offloading data transfer responsibilities from the CPU?",
    "context": "Direct Memory Access (DMA) is a feature of computer systems that allows certain hardware subsystems (like disk drive controllers or network interface cards) to access main system memory (RAM) independently of the central processing unit (CPU). This significantly speeds up large data transfers by freeing the CPU to perform other tasks while the data transfer occurs in the background.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Direct Memory Access (DMA)",
    "options": [
      "Programmed I/O (PIO)",
      "Direct Memory Access (DMA)",
      "Interrupt-driven I/O",
      "Polling"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "I/O Organization",
    "question": "What is the primary advantage of using 'Interrupt-driven I/O' over 'Programmed I/O (Polling)' for managing peripheral devices?",
    "context": "In Programmed I/O (Polling), the CPU continuously checks the status of an I/O device, wasting CPU cycles if the device is slow. Interrupt-driven I/O allows the CPU to proceed with other tasks after initiating an I/O operation. The I/O device generates an interrupt signal to the CPU only when it's ready for the next data transfer or has completed its operation, allowing the CPU to use its time more efficiently.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "The CPU is freed to perform other tasks while waiting for I/O operations to complete, improving CPU utilization.",
    "options": [
      "It eliminates the need for an operating system.",
      "It simplifies the hardware design of peripheral devices.",
      "It always results in faster data transfer rates.",
      "The CPU is freed to perform other tasks while waiting for I/O operations to complete, improving CPU utilization."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "RISC vs CISC",
    "question": "Which architectural philosophy emphasizes a small, highly optimized set of simple, fixed-length instructions, often executed in a single clock cycle, favoring hardware over microcode?",
    "context": "RISC (Reduced Instruction Set Computer) architecture is characterized by a small, highly optimized set of instructions, typically of fixed length, which can often be executed in a single clock cycle. This simplifies the CPU's control unit and pipelining, and emphasizes software (compilers) to achieve complex operations by combining simple instructions. This contrasts with CISC, which features a large, complex instruction set.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "RISC (Reduced Instruction Set Computer)",
    "options": [
      "RISC (Reduced Instruction Set Computer)",
      "Von Neumann Architecture",
      "VLIW (Very Long Instruction Word)",
      "CISC (Complex Instruction Set Computer)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Computer Architecture",
    "subtopic": "RISC vs CISC",
    "question": "Compared to a RISC processor, what is a key characteristic of a CISC (Complex Instruction Set Computer) processor, particularly regarding its instruction set and implementation?",
    "context": "CISC (Complex Instruction Set Computer) processors feature a large instruction set with many specialized instructions, some of which can perform multi-step operations (e.g., memory access, arithmetic, and conditional branching in one instruction). These instructions are often of variable length and are typically implemented using microcode, allowing for complex operations to be executed by a single instruction, potentially simplifying assembly programming but complicating hardware design and pipelining.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "It has a large, complex instruction set with variable-length instructions, often implemented with microcode.",
    "options": [
      "It has a large, complex instruction set with variable-length instructions, often implemented with microcode.",
      "It uses a load-store architecture, where only load and store instructions access memory.",
      "It requires compilers to generate highly optimized and complex instruction sequences.",
      "It primarily focuses on single-cycle execution for all instructions."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Logic Gates and Boolean Algebra",
    "question": "Which logic gate outputs true only when both its inputs are true?",
    "context": "An AND gate outputs true if and only if all its inputs are true.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "AND gate",
    "options": [
      "OR gate",
      "NAND gate",
      "AND gate",
      "XOR gate"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Boolean Algebra",
    "question": "According to Boolean algebra, what is the result of A + A' (where A' is complement of A)?",
    "context": "The Boolean expression A + A' always equals 1.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "1",
    "options": [
      "A'",
      "A",
      "0",
      "1"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Combinational Circuits",
    "question": "Which combinational circuit selects one input out of many and forwards it to a single output line?",
    "context": "A multiplexer selects one of many inputs to pass to the output.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Multiplexer (MUX)",
    "options": [
      "Decoder",
      "Multiplexer (MUX)",
      "Encoder",
      "Demultiplexer (DEMUX)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Combinational Circuits",
    "question": "Which device converts binary information from 2^n input lines to n output lines?",
    "context": "An encoder reduces multiple inputs into fewer outputs by encoding the active input.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Encoder",
    "options": [
      "Encoder",
      "Multiplexer",
      "Demultiplexer",
      "Decoder"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits",
    "question": "Which flip-flop changes state only on the triggering edge of the clock signal?",
    "context": "Edge-triggered flip-flops respond to changes at the clock edge, enabling synchronous designs.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "Edge-triggered flip-flop",
    "options": [
      "Edge-triggered flip-flop",
      "SR flip-flop",
      "JK flip-flop",
      "Level-triggered flip-flop"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits",
    "question": "In sequential circuits, what is the primary function of a finite state machine (FSM)?",
    "context": "FSMs control the sequence of operations by transitioning between states according to inputs.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "To control sequences based on inputs and states",
    "options": [
      "To control sequences based on inputs and states",
      "To perform arithmetic operations",
      "To store binary data permanently",
      "To amplify signals"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits",
    "question": "Which circuit counts the number of clock pulses applied to it?",
    "context": "Counters keep track of the number of clock pulses for timing and control purposes.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Counter",
    "options": [
      "Counter",
      "Shift register",
      "Decoder",
      "Multiplexer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Logic Gates",
    "question": "Which logic gate produces an output of 1 only when both inputs are 1?",
    "context": "An AND Gate outputs 1 only when all its inputs are 1, implementing the logical conjunction operation in digital circuits.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "AND Gate",
    "options": [
      "OR Gate",
      "XOR Gate",
      "NAND Gate",
      "AND Gate"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Boolean Algebra",
    "question": "Which Boolean algebra law states that A + A = A?",
    "context": "The Idempotent Law in Boolean algebra states that A + A = A and A · A = A, simplifying expressions by eliminating redundant terms.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Idempotent Law",
    "options": [
      "Idempotent Law",
      "Commutative Law",
      "Absorption Law",
      "Distributive Law"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Combinational Circuits",
    "question": "Which combinational circuit selects one of many input lines and directs it to a single output line based on a selection input?",
    "context": "A Multiplexer (MUX) selects one of several input signals based on a control input and forwards it to a single output, commonly used for data routing in digital systems.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Multiplexer",
    "options": [
      "Multiplexer",
      "Demultiplexer",
      "Encoder",
      "Decoder"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Combinational Circuits",
    "question": "Which combinational circuit converts a binary input into a coded output representing the input’s position?",
    "context": "An Encoder converts a single active input line into a binary code, typically used to reduce the number of bits needed to represent input signals, such as in keyboard encoding.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Encoder",
    "options": [
      "Multiplexer",
      "Demultiplexer",
      "Decoder",
      "Encoder"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits",
    "question": "Which sequential circuit element stores a single bit and changes its state based on a clock signal?",
    "context": "A Flip-Flop is a basic sequential circuit element that stores one bit of data, changing its state on clock edges, serving as a building block for memory and registers.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Flip-Flop",
    "options": [
      "Counter",
      "Register",
      "Flip-Flop",
      "Shift Register"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits",
    "question": "Which type of counter increments its value by one on each clock pulse, cycling through a fixed sequence?",
    "context": "A Binary Counter is a sequential circuit that increments its count in binary on each clock pulse, cycling through 0 to 2^n - 1 for n bits, used in timers and frequency dividers.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Binary Counter",
    "options": [
      "Johnson Counter",
      "Binary Counter",
      "Ring Counter",
      "Gray Code Counter"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits",
    "question": "Which sequential circuit uses a finite set of states and transitions to model system behavior based on inputs and current state?",
    "context": "A Finite State Machine (FSM) models a system with a finite number of states, transitioning based on inputs and current state, used in control units and protocol implementations.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Finite State Machine",
    "options": [
      "Multiplexer",
      "Finite State Machine",
      "Counter",
      "Shift Register"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Logic Gates and Boolean Algebra",
    "question": "A digital circuit needs to output '1' only when its two inputs are different. Which fundamental logic gate implements this exact functionality?",
    "context": "The XOR (Exclusive OR) gate is a fundamental logic gate whose output is '1' if the inputs are different, and '0' if the inputs are the same. This behavior is crucial for various digital operations, including parity checking and binary addition (sum bit).",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "XOR (Exclusive OR) gate",
    "options": [
      "NOT gate",
      "AND gate",
      "XOR (Exclusive OR) gate",
      "OR gate"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Logic Gates and Boolean Algebra",
    "question": "Using only NAND gates, how can a 2-input XOR gate be constructed, and what property of NAND gates makes this possible?",
    "context": "NAND gates (and NOR gates) are 'functionally complete' gates, meaning any Boolean function can be implemented using only NAND gates (or only NOR gates). An XOR gate can be constructed using four NAND gates by realizing its Boolean expression (A'B + AB') using NAND gate equivalents (e.g., A NAND B NAND (A NAND A) NAND (B NAND B)).",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "By combining NAND gates to form an AND-OR-Invert (AOI) structure; NAND is a functionally complete gate.",
    "options": [
      "By connecting two NAND gates in series; NAND gates are idempotent.",
      "It is impossible to construct an XOR gate using only NAND gates.",
      "By combining NAND gates to form an AND-OR-Invert (AOI) structure; NAND is a functionally complete gate.",
      "By using a single NAND gate with an inverted input; NAND gates are commutative."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Combinational Circuits (MUX, DEMUX, Encoder, Decoder)",
    "question": "A system needs to select one of 8 different data inputs and route it to a single output line, based on a 3-bit select code. Which combinational circuit is designed specifically for this purpose?",
    "context": "A Multiplexer (MUX) is a combinational circuit that selects one of several analog or digital input signals and forwards the selected input into a single output line. An 8-to-1 MUX has 8 data inputs, 3 select lines (since $2^3 = 8$), and 1 output. The select lines determine which input is routed to the output.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "8-to-1 Multiplexer (MUX)",
    "options": [
      "8-to-1 Multiplexer (MUX)",
      "3-to-8 Decoder",
      "8-to-3 Encoder",
      "1-to-8 Demultiplexer (DEMUX)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Combinational Circuits (MUX, DEMUX, Encoder, Decoder)",
    "question": "A digital circuit is used to convert a 4-bit binary input into a unique active output line among 16 possible output lines. What type of combinational circuit is this, and what is its primary application?",
    "context": "A Decoder is a combinational circuit that converts binary information from N input lines to a maximum of $2^N$ unique output lines. A 4-to-16 decoder has 4 input bits and $2^4 = 16$ output lines, where only one output line is active (high) at any given time, corresponding to the binary value of the input. Decoders are commonly used in memory addressing, data routing, and enabling specific components based on control signals.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "4-to-16 Decoder; used for address decoding in memory systems or enabling specific devices.",
    "options": [
      "4-to-16 Decoder; used for address decoding in memory systems or enabling specific devices.",
      "16-to-1 Multiplexer; used for selecting one input from many.",
      "16-to-4 Encoder; used for converting multiple inputs to a binary code.",
      "4-bit Full Adder; used for binary arithmetic."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits (Flip-Flops, Counters, FSMs)",
    "question": "What is the fundamental building block of all sequential circuits that is capable of storing one bit of binary information, and whose output depends on both its current inputs and its previous state?",
    "context": "A Flip-Flop is a basic sequential circuit that can store a single bit of information. Unlike combinational circuits whose outputs depend only on current inputs, the output of a flip-flop also depends on its previous state, making it the fundamental memory element in digital systems like registers, counters, and state machines.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Flip-Flop",
    "options": [
      "Flip-Flop",
      "Logic Gate",
      "Encoder",
      "Multiplexer"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits (Flip-Flops, Counters, FSMs)",
    "question": "A finite state machine (FSM) is designed to detect a specific sequence of bits ('101') in a serial input stream. What are the two main components that define the behavior and structure of this FSM?",
    "context": "A Finite State Machine (FSM) (or Finite Automaton) is a mathematical model of computation that consists of a finite number of states, transitions between those states, and actions. Its behavior is defined by its current state and the current input, which determines the next state and the output. For sequence detection, the states represent the parts of the sequence detected so far.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "A set of states, and a set of transitions between states based on inputs.",
    "options": [
      "Only input and output buffers.",
      "A set of states, and a set of transitions between states based on inputs.",
      "Only a clock signal and power supply.",
      "Only combinational logic gates."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Sequential Circuits (Flip-Flops, Counters, FSMs)",
    "question": "What is the primary difference between a 'Mealy machine' and a 'Moore machine' in the context of Finite State Machines (FSMs)?",
    "context": "Mealy and Moore machines are two types of Finite State Machines. The key distinction lies in how their output is generated. In a Mealy machine, the output is a function of both the current state and the current input. In contrast, in a Moore machine, the output is solely a function of the current state. This difference affects design complexity and the timing of outputs relative to inputs and state changes.",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "In a Mealy machine, output depends on current state and input; in a Moore machine, output depends only on current state.",
    "options": [
      "Mealy machines have memory, while Moore machines do not.",
      "Moore machines are always synchronous, while Mealy machines are asynchronous.",
      "In a Mealy machine, output depends on current state and input; in a Moore machine, output depends only on current state.",
      "Mealy machines are always simpler to design than Moore machines."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Logic Gates and Boolean Algebra",
    "subtopic": "Boolean Laws",
    "question": "Which Boolean law states that A + A·B = A?",
    "context": "The Absorption Law in Boolean algebra states that A + A·B = A and A·(A + B) = A, which helps in simplifying Boolean expressions by eliminating redundant terms.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Absorption Law",
    "options": [
      "Absorption Law",
      "De Morgan's Law",
      "Distributive Law",
      "Commutative Law"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Logic Gates and Boolean Algebra",
    "subtopic": "Gate Implementation",
    "question": "What is the minimum number of NAND gates required to implement an XOR gate?",
    "context": "An XOR gate can be implemented using 4 NAND gates by creating the expression (A NAND (A NAND B)) NAND (B NAND (A NAND B)), demonstrating the universal property of NAND gates.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "4",
    "options": [
      "5",
      "2",
      "4",
      "3"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Combinational Circuits",
    "subtopic": "Multiplexer",
    "question": "How many select lines are required for an 8:1 multiplexer?",
    "context": "An 8:1 multiplexer requires 3 select lines because 2^3 = 8, allowing selection among 8 input lines. The select lines determine which input is routed to the output.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "3",
    "options": [
      "3",
      "4",
      "2",
      "8"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Combinational Circuits",
    "subtopic": "Decoder",
    "question": "In a 3:8 decoder with active LOW outputs, what will be the output when input is 101₂?",
    "context": "A 3:8 decoder with active LOW outputs will have only one output line LOW (0) corresponding to the binary input value, while all other outputs remain HIGH (1). For input 101₂ = 5₁₀, output Y5 will be LOW.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Y5 = 0, all others = 1",
    "options": [
      "Y5 = 0, all others = 1",
      "Y3 = 0, all others = 1",
      "All outputs = 0",
      "Y5 = 1, all others = 0"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Sequential Circuits",
    "subtopic": "Flip-Flops",
    "question": "What happens when both J and K inputs of a JK flip-flop are HIGH?",
    "context": "In a JK flip-flop, when both J and K inputs are HIGH (1), the output toggles on each clock pulse, changing from its previous state. This eliminates the race condition present in SR flip-flops.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Output toggles",
    "options": [
      "Output remains unchanged",
      "Output toggles",
      "Output becomes HIGH",
      "Output becomes LOW"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Sequential Circuits",
    "subtopic": "Counters",
    "question": "What is the modulus of a 4-bit ripple counter?",
    "context": "A 4-bit ripple counter has a modulus of 16 because it can count from 0 to 15 (2^4 = 16 states) before resetting back to 0, making it a MOD-16 counter.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "16",
    "options": [
      "16",
      "8",
      "4",
      "15"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Sequential Circuits",
    "subtopic": "Finite State Machines",
    "question": "In a Moore FSM, the output depends on which of the following?",
    "context": "In a Moore Finite State Machine, the output is determined solely by the present state and is independent of the current input. This contrasts with Mealy machines where output depends on both present state and input.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Present state only",
    "options": [
      "Present state only",
      "Present state and input",
      "Previous state only",
      "Present input only"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "Which number system uses base 16 and is commonly used in computer systems for compact representation?",
    "context": "Hexadecimal number system uses base 16 and is widely used for compact representation in computing.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Hexadecimal",
    "options": [
      "Hexadecimal",
      "Octal",
      "Decimal",
      "Binary"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "What is the 2's complement representation primarily used for in digital systems?",
    "context": "2's complement is widely used to represent signed integers in digital systems.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Representing signed integers",
    "options": [
      "Error detection",
      "Floating-point arithmetic",
      "Representing signed integers",
      "Representing unsigned integers"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "Which binary code is designed to reduce errors by having only one bit change between successive numbers?",
    "context": "Gray code is a binary code where only one bit changes between successive values, minimizing errors.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Gray code",
    "options": [
      "Parity code",
      "ASCII code",
      "BCD code",
      "Gray code"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "What is the primary purpose of a Karnaugh map (K-Map) in Boolean algebra?",
    "context": "Karnaugh maps help simplify Boolean expressions by grouping adjacent ones visually.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "To simplify Boolean expressions by visual grouping",
    "options": [
      "To convert Boolean expressions to truth tables",
      "To perform arithmetic operations",
      "To generate random Boolean functions",
      "To simplify Boolean expressions by visual grouping"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "In a 4-variable K-Map, how many cells are there to represent all possible input combinations?",
    "context": "A 4-variable K-Map has 2^4 = 16 cells representing all input combinations.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "16",
    "options": [
      "4",
      "32",
      "8",
      "16"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "Which of the following is a valid group size in K-Map minimization?",
    "context": "Valid groups in K-Maps are powers of two: 1, 2, 4, 8, etc., used to simplify expressions.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "4",
    "options": [
      "5",
      "4",
      "6",
      "3"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "Which number representation uses the most significant bit to indicate the sign and the remaining bits for the magnitude of a number?",
    "context": "In Sign-Magnitude representation, the most significant bit denotes the sign (0 for positive, 1 for negative), and the remaining bits represent the magnitude, used in early computing systems.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Sign-Magnitude",
    "options": [
      "Gray Code",
      "Sign-Magnitude",
      "Two’s Complement",
      "One’s Complement"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "Which representation is most commonly used in modern computers for representing negative integers due to its ease of arithmetic operations?",
    "context": "Two’s Complement is widely used for negative integers in computers because it simplifies addition and subtraction operations, requiring only a single arithmetic circuit.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Two’s Complement",
    "options": [
      "One’s Complement",
      "Excess-N Code",
      "Sign-Magnitude",
      "Two’s Complement"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "Which term in a K-Map represents a group of 1s that can be combined to simplify a Boolean expression?",
    "context": "In a K-Map, a Minterm Group is a collection of adjacent 1s (representing true outputs) that can be combined to form a simplified product term in the Boolean expression.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Minterm Group",
    "options": [
      "Prime Implicant",
      "Don’t Care Condition",
      "Minterm Group",
      "Maxterm Group"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "What is the maximum number of variables that can be effectively minimized using a 4-variable K-Map?",
    "context": "A 4-variable K-Map is a 4x4 grid used to minimize Boolean functions with up to 4 variables, allowing simplification of expressions with 16 possible minterms.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "4",
    "options": [
      "6",
      "5",
      "3",
      "4"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "Which number representation changes only one bit between consecutive values, reducing errors in digital systems?",
    "context": "Gray Code, or reflected binary code, ensures that only one bit changes between consecutive values, minimizing errors in applications like rotary encoders and analog-to-digital conversion.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Gray Code",
    "options": [
      "Gray Code",
      "Sign-Magnitude",
      "Two’s Complement",
      "BCD"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "Which K-Map simplification technique identifies the largest possible groups of 1s that cannot be further combined?",
    "context": "A Prime Implicant in a K-Map is a maximal group of 1s (or 1s and don’t cares) that cannot be combined with other groups, forming a minimal sum-of-products expression.",
    "difficulty": "advanced",
    "type": "mcq",
    "answer": "Prime Implicant",
    "options": [
      "Minterm Expansion",
      "Essential Prime Implicant",
      "Prime Implicant",
      "Don’t Care Condition"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "An 8-bit signed integer uses 2's complement representation. What is the decimal value of the binary number `10110100`?",
    "context": "In 2's complement representation, to find the decimal value of a negative number (indicated by a '1' in the most significant bit), first invert all bits and add 1 to get its positive counterpart. Then, append a negative sign. For `10110100`: Invert to `01001011`. Add 1: `01001100`. Convert `01001100` to decimal: $2^2 + 2^3 + 2^6 = 4 + 8 + 64 = 76$. So, the original number is -76.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "-76",
    "options": [
      "-116",
      "76",
      "180",
      "-76"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "What is the primary reason that 'Excess-3' code is considered a self-complementing code?",
    "context": "Excess-3 code is a non-weighted BCD (Binary Coded Decimal) code where each decimal digit is represented by its 4-bit binary equivalent plus 3. It's a self-complementing code because the 9's complement of a decimal digit (e.g., 9-2=7) can be found by simply inverting all the bits of its Excess-3 code representation (e.g., Excess-3 for 2 is 0101, for 7 is 1010, which are bit-wise complements).",
    "difficulty": "advance",
    "type": "mcq",
    "answer": "The 9's complement of a decimal digit can be obtained by simply complementing each bit of its Excess-3 representation.",
    "options": [
      "It uses only 3 bits to represent a decimal digit.",
      "It is directly convertible to BCD (Binary Coded Decimal).",
      "It eliminates the need for separate sign bits.",
      "The 9's complement of a decimal digit can be obtained by simply complementing each bit of its Excess-3 representation."
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "Which number system is most commonly used internally by computers to represent data?",
    "context": "Computers internally use the binary number system to represent all data and instructions.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Binary",
    "options": [
      "Binary",
      "Hexadecimal",
      "Decimal",
      "Octal"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "What does the term 'floating point representation' refer to in computer arithmetic?",
    "context": "Floating point representation is used to represent real numbers in computing with fixed precision.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Representation of real numbers with a fixed number of significant digits",
    "options": [
      "Representation of integers only",
      "Binary-coded decimals",
      "Representation of real numbers with a fixed number of significant digits",
      "Error checking in numbers"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Number Representations",
    "question": "In signed magnitude representation, what bit indicates the sign of a number?",
    "context": "Signed magnitude representation uses the MSB to indicate whether the number is positive or negative.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "Most significant bit (MSB)",
    "options": [
      "Middle bit",
      "Least significant bit (LSB)",
      "Parity bit",
      "Most significant bit (MSB)"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "What is the advantage of grouping larger numbers of 1s in K-Map simplification?",
    "context": "Grouping larger groups of 1s in Karnaugh maps helps reduce the complexity of Boolean expressions.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "It results in simpler Boolean expressions with fewer terms",
    "options": [
      "It results in simpler Boolean expressions with fewer terms",
      "It reduces accuracy",
      "It increases the number of variables",
      "It makes the circuit slower"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "How are cells arranged in a Karnaugh map to ensure adjacency for simplification?",
    "context": "Karnaugh maps use Gray code ordering to place adjacent cells differing by one bit for simplification.",
    "difficulty": "intermediate",
    "type": "mcq",
    "answer": "Using Gray code sequence",
    "options": [
      "Using random order",
      "Using decimal sequence",
      "Using Gray code sequence",
      "Using binary sequence"
    ]
  },
  {
    "goal": "GATE CSE",
    "topic": "Digital Logic",
    "subtopic": "Minimization using K-Maps",
    "question": "What is the minimal number of variables that can be simplified using a K-Map?",
    "context": "Karnaugh maps can simplify Boolean expressions starting from 1 variable up to several variables.",
    "difficulty": "beginner",
    "type": "mcq",
    "answer": "1",
    "options": [
      "0",
      "1",
      "3",
      "2"
    ]
  }
]